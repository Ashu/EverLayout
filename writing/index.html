<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Writing Layouts - EverLayout Documentation</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Writing Layouts";
    var mkdocs_page_input_path = "writing.md";
    var mkdocs_page_url = "/writing/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> EverLayout Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Getting Started</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Writing Layouts</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#writing-layouts">Writing Layouts</a></li>
                
                    <li><a class="toctree-l4" href="#format">Format </a></li>
                
                    <li><a class="toctree-l4" href="#the-layout-index">The Layout Index </a></li>
                
                    <li><a class="toctree-l4" href="#the-view-model">The View Model </a></li>
                
                    <li><a class="toctree-l4" href="#view-name">View Name </a></li>
                
                    <li><a class="toctree-l4" href="#creating-new-views">Creating New Views </a></li>
                
                    <li><a class="toctree-l4" href="#creating-new-views-from-uiview-subclasses">Creating New Views From UIView Subclasses </a></li>
                
                    <li><a class="toctree-l4" href="#writing-constraints">Writing Constraints </a></li>
                
                    <li><a class="toctree-l4" href="#size-classes">Size Classes </a></li>
                
                    <li><a class="toctree-l4" href="#view-properties">View Properties </a></li>
                
                    <li><a class="toctree-l4" href="#navigation-bar-properties">Navigation Bar Properties </a></li>
                
                    <li><a class="toctree-l4" href="#z-index">Z-Index </a></li>
                
                    <li><a class="toctree-l4" href="#subviews">Subviews </a></li>
                
                    <li><a class="toctree-l4" href="#templates">Templates </a></li>
                
                    <li><a class="toctree-l4" href="#data-injection">Data Injection </a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../reading/">Reading Layouts</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../formats/">Layout Formats</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../bridge/">EverLayout Bridge</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">EverLayout Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Writing Layouts</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="writing-layouts">Writing Layouts</h1>
<h2 id="format">Format <a name="format"></a></h2>
<p>EverLayout uses a collection of parser protocols to retrieve the pertinent layout information from your layout files.
Theoretically, layouts can be written in any format as long as you can provide working parsers.</p>
<p>The following documentation demonstrates how to use EverLyout to write layouts for the default
JSON parsers, however if you're interested
in writing layouts using a different format or general structure, read <a href="/EverLayout/formats">Layout Formats</a>
to see how to write your own parsers.</p>
<h2 id="the-layout-index">The Layout Index <a name="layout-index"></a></h2>
<p>The layout index is the root of every layout model.</p>
<pre><code>{
    &quot;name&quot;:&quot;SimpleLayout&quot;,
    &quot;root&quot;:{...},
    &quot;templates&quot;:{...},
    &quot;controllerTitle&quot;:&quot;My App!&quot;,
    &quot;navigationBar&quot;:{...}
}
</code></pre>

<p>5 properties are currently read in the Layout Index:</p>
<ul>
<li><code>name</code> The layout name. So far this is only used 
to route layout updates when developing with EverLayout Bridge.</li>
<li><code>root</code> Layouts are built on UIViews, which become the 'root view'
of the layout. This will most typically be your View Controller's view.</li>
<li><code>templates</code> EverLayout supports templates which are reusable throughout the entire layout.
Think of these as super-classes for your view models.</li>
<li><code>controllerTitle</code> If your layout is built on a view contained in a <code>UINavigationController</code>, this
property will set the title of the <code>UINavigationBar</code>.</li>
<li><code>navigationBar</code> Responsible for setting other <code>UINavigationBar</code> properties.</li>
</ul>
<h2 id="the-view-model">The View Model <a name="view-model"></a></h2>
<p>The view model contains layout data for individual UIViews.</p>
<pre><code>{
    &quot;template&quot;:&quot;exampleTemplate&quot;,
    &quot;constraints&quot;:{...},
    &quot;properties&quot;:{...},
    &quot;z-index&quot;:&quot;2&quot;,
    &quot;views&quot;:{...}
}
</code></pre>

<ul>
<li><code>template</code> See <a href="#templates">Templates</a></li>
<li><code>constraints</code> See <a href="#writing-constraints">Writing Constraints</a></li>
<li><code>properties</code> See <a href="#view-properties">View Properties</a></li>
<li><code>z-index</code> See <a href="#z-index">Z-Index</a></li>
<li><code>views</code> See <a href="#subviews">Subviews</a></li>
</ul>
<h2 id="view-name">View Name <a name="view-name"></a></h2>
<p>Every view in the layout (except the root view, see <a href="#view-index">View Index</a>)
has a name and is expressed as a subview of another view in this layout.</p>
<pre><code>{
    ...
    &quot;views&quot;:{
        &quot;actionButton&quot;:{
            // View model data
        }
    }
}
</code></pre>

<p>The key in the key-value pair is the view's name, and the value is its <a href="#view-model">view model</a>.</p>
<p>In the sample, EverLayout would scan this layout's view environment
for a property with the name 'actionButton'. If it finds one, it will 
map this view model to that UIView, including adding it as 
a subview.</p>
<p>If EverLayout is unable to find the view, it will attempt to find 
the property in the environment's super-classes, before moving on. </p>
<h2 id="creating-new-views">Creating New Views <a name="creating-views"></a></h2>
<p>The default behaviour for EverLayout is to find the view being referenced
by scanning the properties of its view environment. However in 
some cases you may wish to create new views from inside the layout 
file and have them become a part of your view hierarchy.</p>
<p>This means:</p>
<ul>
<li>You can create basic views to test layout ideas without having to
re-compile (when using EverLayout Bridge).</li>
<li>Views with basic functionality (like wrappers for other views)
no longer need to be described in your code.</li>
<li>More sophisticated layout updates can be made without
having to update your code and re-submit your app.</li>
</ul>
<p>If your view name is prefixed with <code>!</code>, it will be considered a
'new view' and created during the build process.</p>
<pre><code>{
    &quot;!newWrapperView&quot;:{
        // View model data
    }
}
</code></pre>

<h2 id="creating-new-views-from-uiview-subclasses">Creating New Views From UIView Subclasses <a name="creating-subclasses"></a></h2>
<p>In addition to being able to create new views, you can also
specify which UIView subclass you want your new view to be.</p>
<pre><code>{
    &quot;!newImageView:UIImageView&quot;: {
        ...
    }
}
</code></pre>

<p>Append the name of your new view with <code>:</code> followed by 
a class name. In the example EverLayout creates a new 
UIImageView.</p>
<p>To create an instance of a custom class, you must also 
specify your application namespace, like so:</p>
<p><code>!myNewClassInstance:MyApp.MyClassName</code></p>
<h2 id="writing-constraints">Writing Constraints <a name="writing-constraints"></a></h2>
<p>EverLayout uses AutoLayout constraints to position its elements.
The constraints for each view are generated during the layout
build based on key-value rules in the view model.</p>
<p>The constraint arguments can be written in comprehensive and shorthand formats.</p>
<p>Shorthand constraints are written as key-value pairs; The key denotes which attributes 
to constrain, and the value is a representation of the layout arguments to apply
to each of these attributes. The syntax for shorthand constraints may be difficult to read at first,
but after becoming familiar with this approach, layout design will be a much quicker process.</p>
<h4 id="comprehensive">Comprehensive</h4>
<pre><code>{
    &quot;constraints&quot;:{
        &quot;top right bottom left&quot;:{
            &quot;to&quot;:&quot;super&quot;
        }
    }
}
</code></pre>

<h4 id="shorhand">Shorhand</h4>
<pre><code>{
    &quot;constraints&quot;:{
        &quot;top right bottom left&quot;:&quot;@super&quot;
    }
}
</code></pre>

<p>The example above creates 4 NSLayoutConstraints that attach
the left, top, right and bottom attributes of this view to 
their counterparts in the superview.</p>
<h4 id="comprehensive_1">Comprehensive</h4>
<pre><code>{
    &quot;constraints&quot;:{
        &quot;bottom left right&quot;:{
            &quot;to&quot;:&quot;super&quot;,
            &quot;inset&quot;:8
        },
        &quot;height&quot;:{
            &quot;to&quot;:&quot;super&quot;,
            &quot;multiplier&quot;:0.5
        }
    }
}
</code></pre>

<h4 id="shorthand">Shorthand</h4>
<pre><code>{
    &quot;constraints&quot;:{
        &quot;bottom left right&quot;:&quot;@super &lt;8&quot;,
        &quot;height&quot;:&quot;@super /2&quot;
    }
}
</code></pre>

<p>The second example creates constraints which tether the bottom, left and 
right edges to the superview with an 8 unit inset, and then gives this view a height 
of half the superview height.</p>
<p>In the attribute declarations (the key), and the shorthand arguments (the value), each argument
is space separated.</p>
<p>For the left-hand statement, any NSLayoutAttribute is valid 
along with some additional 'compound attributes'.</p>
<ul>
<li><code>edges</code> Translates to <code>top</code> <code>left</code> <code>right</code> <code>bottom</code></li>
<li><code>center</code> Translates to <code>centerX</code> <code>centerY</code></li>
<li><code>margins</code> Translates to <code>marginLeft</code> <code>marginRight</code></li>
</ul>
<p>The right-hand statement can have many arguments, each denoted by
a modifier character in shorthand.</p>
<ul>
<li><code>to</code> / <code>@</code> Target a view in the layout / view environment</li>
<li><code>attribute</code> / <code>.</code> A dot separator can be added to a target name to specify 
an NSLayoutAttribute of that view to target (e.g <code>@viewName.right</code>)</li>
<li><code>constant</code> / <code>+</code> / <code>-</code> A constant (positive or negative)</li>
<li><code>inset</code> / <code>&lt;</code> An inset constant, which is basically a constant where <code>+</code> and <code>-</code> are inferred from context</li>
<li><code>multiplier</code> / <code>*</code> / <code>/</code> A multiplier or convenience divider</li>
<li><code>identifier</code> / <code>!</code> Constraint identifier (for debugging)</li>
<li><code>relation</code> / <code>%</code> A relation (e.g <code>%&gt;=</code> creates a 'greater than or equal to' relation). Comprehensive
values are <code>gte</code> and <code>lte</code>.</li>
<li><code>priority</code> / <code>$</code> A constraint priority</li>
<li><code>identifier</code> / <code>!</code> Give the constraints an identifier to more easily identify them in the console</li>
</ul>
<p><strong>Note:</strong>
EverLayout will try to infer missing constraint properties based
on the information that is supplied.</p>
<p><code>"width": "@view +12"</code> Will create a constraint with the width
of <code>view</code>, plus 12 units.</p>
<p><code>"width": "+12"</code> Will create a constraint that has a width of 
12 units.</p>
<h4 id="multiple-constraints">Multiple constraints</h4>
<p>Since in JSON structures a key is unique, each layout attribute can only have 
one constraint argument, which will cause problems if you wish to have multiple constraints
with different priorities or relations. To get around this the constraint arguments can be 
an array of the comprehensive and shorthand arguments described above.</p>
<pre><code>{
    &quot;constraints&quot;:{
        &quot;width&quot;:[
            {
                &quot;constant&quot;:100,
                &quot;priority&quot;:500
            },
            {
                &quot;constant&quot;:150,
                &quot;priority&quot;:700
            }
        ]
    }
}
</code></pre>

<h2 id="size-classes">Size Classes <a name="size-classes"></a></h2>
<p>A single layout file can support multiple screen sizes/orientations by allowing the activation
and deactivation of layout constraints dependant on size classes. </p>
<p>Size classes are applied as regular constraint properties as demonstrated above but will prevent 
the activation of the constraint unless the view we're working with matches the specified size classes.</p>
<p>Like the other properties, the size classes have both comprehensive and shorthand syntax.</p>
<ul>
<li><code>horizontalSizeClass / h</code></li>
<li><code>verticalSizeClass / c</code></li>
</ul>
<p>with value options:</p>
<ul>
<li><code>regular / r</code></li>
<li><code>compact / c</code></li>
</ul>
<pre><code>{
    &quot;constraints&quot;:{
        &quot;width height&quot;:[
            &quot;+50 hc vc&quot;,
            &quot;+100 hr vc&quot;
        ]
    }
}
</code></pre>

<pre><code>{
    &quot;constraints&quot;:{
        &quot;width height&quot;:{
            [
                &quot;constant&quot;:50,
                &quot;horizontalSizeClass&quot;:&quot;compact&quot;,
                &quot;verticalSizeClass&quot;:&quot;compact&quot;
            ],
            [
                &quot;constant&quot;:100,
                &quot;horizontalSizeClass&quot;:&quot;compact&quot;,
                &quot;verticalSizeClass&quot;:&quot;regular&quot;
            ]
        }
    }
}
</code></pre>

<p>The examples above will constrain the view to a width and height of 50 points
in a horizontal iPhone, and the same view to a width and height of 100 points in a vertical
iPhone.</p>
<h3 id="updating-trait-collection-at-runtime">Updating trait collection at runtime</h3>
<p>If the case of having different constraints for device orientations, you'll want to be able to update
the layout at runtime when the trait collection updates. You can do this by overriding 
<code>willTransitionToNewCollection</code>.</p>
<pre><code>    override func willTransition(to newCollection: UITraitCollection, with coordinator: UIViewControllerTransitionCoordinator) {
        super.willTransition(to: newCollection, with: coordinator)

        self.layout.updateConstraints(withTraitColelction: newCollection)
    }
</code></pre>

<h2 id="view-properties">View Properties <a name="view-properties"></a></h2>
<p>Some properties of UIView (and its subclasses) have been made settable
in the layout files. You can set these under <code>properties</code> in the view model.</p>
<p>These are the properties currently available:</p>
<p><strong> UIView </strong></p>
<ul>
<li><code>frame</code> Value is passed into CGRectFromString</li>
<li><code>backgroundColor</code> Color can be the name of the color (<code>red</code>) or a hex 
string (<code>#333333</code>).</li>
<li><code>hidden</code> (isHidden)</li>
<li><code>cornerRadius</code> Translates to <code>layer.cornerRadius</code></li>
<li><code>borderWidth</code> Translates to <code>layer.borderWidth</code></li>
<li><code>borderColor</code> Translates to <code>layer.borderColor</code></li>
<li><code>alpha</code></li>
<li><code>clipToBounds</code></li>
<li><code>contentMode</code></li>
<li><code>hidden</code></li>
</ul>
<p><strong> UILabel </strong></p>
<ul>
<li><code>text</code></li>
<li><code>textColor</code></li>
<li><code>lineBreakMode</code></li>
<li><code>textAlignment</code></li>
<li><code>numberOfLines</code></li>
<li><code>fontSize</code></li>
</ul>
<p><strong> UIButton </strong></p>
<ul>
<li><code>text</code> Translates to a call to setTitle(...)</li>
<li><code>fontSize</code></li>
<li><code>textColor</code> Translates to a call to setTitleColor(...)</li>
<li><code>backgroundImage</code> Translates to a call to setBackgroundImage(...)</li>
<li><code>image</code> Translates to a call to setImage(...)</li>
</ul>
<p><strong> UIImageView </strong></p>
<ul>
<li><code>image</code> The value used is passed into UIImage(named: ...). If there is no local asset found,
EverLayout will check if the value is a URL and attempt to load a remote image (this is helpful 
for development, but probably not practical for production).</li>
</ul>
<p><strong> UIScrollView </strong></p>
<ul>
<li><code>contentInset</code> Value is passed into UIEdgeInsetFromString</li>
<li><code>contentOffset</code> Value is passed in CGPointFromString</li>
</ul>
<p><strong> UITextField </strong></p>
<ul>
<li><code>placeholder</code></li>
</ul>
<h2 id="navigation-bar-properties">Navigation Bar Properties <a name="navigation-bar"></a></h2>
<p>If your root view is contained within a <code>UINavigationController</code>, you can set properties
for the UINavigationBar within your view index, like so:</p>
<pre><code>{
    &quot;name&quot;:&quot;layout-name&quot;,
    &quot;root&quot;:{
        ...
    },
    &quot;navigaitonBar&quot;:{
        // Properties
    }
}
</code></pre>

<p>These are the available properties:</p>
<ul>
<li><code>textColor</code></li>
<li><code>translucent</code></li>
<li><code>backgroundColor</code></li>
<li><code>tintColor</code></li>
</ul>
<h2 id="z-index">Z-Index <a name="z-index"></a></h2>
<p>The order in which EverLayout adds subviews is not always clear. If you
have views which overlap each other, the <code>z-index</code> can be set 
to tell EverLayout which views should be at the top.</p>
<pre><code>{
    &quot;onBottom&quot;: {
        &quot;z-index&quot;:&quot;1&quot;
    },
    &quot;onTop&quot;:{
        &quot;z-index&quot;:&quot;2&quot;
    }
}
</code></pre>

<p>Like in CSS, the higher the <code>z-index</code> the closer to the surface the view
will be.</p>
<h2 id="subviews">Subviews <a name="subviews"></a></h2>
<p>Every view in the layout (except the root view) is added as a subview 
of another. Subviews are added like so:</p>
<pre><code>{
    &quot;constraints&quot;: {...},
    &quot;properties&quot;:{...},
    &quot;views&quot;:{
        &quot;firstSubview&quot;:{
            ...
        },
        &quot;secondSubview&quot;: {
            ...
        }
    }
}
</code></pre>

<p>The key is the view's name (see <a href="#view-name">view names</a>), and the value
is the view model (see <a href="#view-model">view model</a>).</p>
<h2 id="templates">Templates <a name="templates"></a></h2>
<p>A layout can have templates to be reused.</p>
<pre><code>{
    &quot;name&quot;:&quot;LayoutExample&quot;,
    &quot;root&quot;:{
        &quot;!buttonOne:UIButton&quot;:{
            &quot;template&quot;:&quot;button&quot;,
            &quot;properties&quot;:{
                ...
            },
            &quot;constraints&quot;:{
                ...
            }
        },
        &quot;!button2:UIButton&quot;:{
            &quot;template&quot;:&quot;button&quot;,
            &quot;properties&quot;:{
                ...
            },
            &quot;constraints&quot;:{
                ...
            }
        }
    },
    &quot;templates&quot;:{
        &quot;button&quot;:{
            &quot;properties&quot;:{
                &quot;backgroundColor&quot;:&quot;#333333&quot;
            },
            &quot;constraints&quot;:{
                &quot;width&quot;:&quot;+200&quot;,
                &quot;height&quot;:&quot;+40&quot;
            }
        }
    }
}
</code></pre>

<p>In the example the layout is creating two new buttons that are both inheriting the same properties
from the template <code>button</code>. </p>
<p>Templates currently support <code>properties</code> and <code>constraints</code>.</p>
<p>A view can inherit from multiple templates by passing the names into an array.</p>
<pre><code>{
    &quot;!myView&quot;:{
        &quot;template&quot;:[&quot;firstTemplate&quot; , &quot;secondTemplate&quot;]
    }
}
</code></pre>

<h2 id="data-injection">Data Injection <a name="data-injection"></a></h2>
<p>'Data Injection' is a glorified 'Find and Replace' on your source layout
data. You can mark 'variables' in your layout files like so: <code>#{propertyName}</code></p>
<pre><code>{
    &quot;viewName&quot;:{
        &quot;properties&quot;:{
            &quot;backgroundColor&quot;:&quot;#{color}&quot;
        }
    }
}
</code></pre>

<p>Before building your layout:</p>
<pre><code>    self.layout?.injectData([
        &quot;color&quot;:&quot;red&quot;
    ])
</code></pre>

<p>EverLayout will replace all instances of <code>#{color}</code> in your layout
with <code>red</code>.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../reading/" class="btn btn-neutral float-right" title="Reading Layouts">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href=".." class="btn btn-neutral" title="Getting Started"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href=".." style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../reading/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../js/theme.js"></script>

</body>
</html>
