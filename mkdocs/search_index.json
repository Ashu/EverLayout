{
    "docs": [
        {
            "location": "/", 
            "text": "EverLayout\n\n\nEverLayout translates JSON/XML data into iOS layouts which can be downloaded, reused and updated at runtime.\n\n\nFeatures\n\n\n\n\nCreate comprehensive layouts without the clumsiness of \nInterface Builder or view controllers bloated with layout code.\n\n\nDownloadable layouts - Layouts written in JSON can be downloaded\nfrom a web server, meaning an App UI can be updated without \nhaving to submit for App Review.\n\n\nBuild layouts with real-time update using a simple HTTP server (or \nEverLayout Bridge\n).\n\n\nA/B Testing - Testing multiple UIs with your users is easy\nwhen building a layout is just loading a file.\n\n\n\n\nInstallation\n\n\nCocoapods\n\n\nAdd EverLayout to your \nPodfile\n\n\nplatform :ios, '8.0'\nuse_frameworks!\npod 'Everlayout'\n\n\n\n\nCarthage\n\n\nCreate a Cartfile that lists the framework and run carthage update.\n\n\ngithub \nacrocat/EverLayout\n\n\n\n\n\nEverLayout Bridge\n\n\nEverLayout Bridge can be installed via Node Package Manager.\n\n\nnpm install -g ever-layout-bridge\n\n\n\n\nMore info \nhere\n\n\nUsage Example\n\n\nLayout file\n\n\n{\n    \nname\n:\nViewController\n,\n    \nroot\n:{\n        \nviews\n:{\n            \nexampleButton\n:{\n                \nconstraints\n:{\n                    \ncenter\n:\n@super\n,\n                    \nwidth\n:\n+120\n,\n                    \nheight\n:\n+80\n\n                },\n                \nproperties\n:{\n                    \ntext\n:\nTap Me!\n\n                }\n            }\n        }\n    }\n}\n\n\n\n\nSwift\n\n\nimport UIKit\nimport EverLayout\n\nclass ViewController: UIViewController {\n    private var layout : EverLayout?\n    public let exampleButton : UIButton = UIButton()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource: \nViewController\n, ofType: \njson\n, inDirectory: \nLayouts\n)!) as! Data\n        self.layout = EverLayout(layoutData: layoutData)\n        self.layout?.build(onView: self.view, viewEnvironment: self)\n    }\n}\n\n\n\n\nSimple Example\n\n\n\n\n{\n    \nname\n:\nViewController\n,\n    \nroot\n:{\n        \nviews\n:{\n            \n!redSquare\n:{\n                \nconstraints\n: {\n                    \nwidth height\n:\n+180\n,\n                    \ncenter\n:\n@super \n24\n\n                },\n                \nproperties\n:{\n                    \nbackgroundColor\n:\nred\n\n                }\n            }\n        }\n    }\n}\n\n\n\n\nHere I am running a blank application in the simulator side-by-side\nwith a ViewController layout described in JSON, which is loaded by the default\nView Controller. The app has connected to EverLayout Bridge \nwhich is serving layout updates every time I save the layout file.\n\n\nEvery time I update the JSON, the App clears and rebuilds the \nlayout with the new data.\n\n\nIn the example I am just changing the properties of a UIView \nto show how layouts can be designed/built without having to re-compile\nthe app.\n\n\nDiscussion\n\n\nAt the moment EverLayout is more of an experiment than a solution.\nThe idea was born through frustration of Interface Builder \nand the existing alternative of clunky layout code.\n\n\nThe goal of this project is to find a middle ground which can offer the real-time\n'visual' approach of IB, and the flexibility and re-usability of\nlayouts described with code.\n\n\nFurther Reading\n\n\nBuilding and distributing iOS Layouts with EverLayout", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#everlayout", 
            "text": "EverLayout translates JSON/XML data into iOS layouts which can be downloaded, reused and updated at runtime.", 
            "title": "EverLayout"
        }, 
        {
            "location": "/#features", 
            "text": "Create comprehensive layouts without the clumsiness of \nInterface Builder or view controllers bloated with layout code.  Downloadable layouts - Layouts written in JSON can be downloaded\nfrom a web server, meaning an App UI can be updated without \nhaving to submit for App Review.  Build layouts with real-time update using a simple HTTP server (or  EverLayout Bridge ).  A/B Testing - Testing multiple UIs with your users is easy\nwhen building a layout is just loading a file.", 
            "title": "Features"
        }, 
        {
            "location": "/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/#cocoapods", 
            "text": "Add EverLayout to your  Podfile  platform :ios, '8.0'\nuse_frameworks!\npod 'Everlayout'", 
            "title": "Cocoapods"
        }, 
        {
            "location": "/#carthage", 
            "text": "Create a Cartfile that lists the framework and run carthage update.  github  acrocat/EverLayout", 
            "title": "Carthage"
        }, 
        {
            "location": "/#everlayout-bridge", 
            "text": "EverLayout Bridge can be installed via Node Package Manager.  npm install -g ever-layout-bridge  More info  here", 
            "title": "EverLayout Bridge"
        }, 
        {
            "location": "/#usage-example", 
            "text": "", 
            "title": "Usage Example"
        }, 
        {
            "location": "/#layout-file", 
            "text": "{\n     name : ViewController ,\n     root :{\n         views :{\n             exampleButton :{\n                 constraints :{\n                     center : @super ,\n                     width : +120 ,\n                     height : +80 \n                },\n                 properties :{\n                     text : Tap Me! \n                }\n            }\n        }\n    }\n}", 
            "title": "Layout file"
        }, 
        {
            "location": "/#swift", 
            "text": "import UIKit\nimport EverLayout\n\nclass ViewController: UIViewController {\n    private var layout : EverLayout?\n    public let exampleButton : UIButton = UIButton()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource:  ViewController , ofType:  json , inDirectory:  Layouts )!) as! Data\n        self.layout = EverLayout(layoutData: layoutData)\n        self.layout?.build(onView: self.view, viewEnvironment: self)\n    }\n}", 
            "title": "Swift"
        }, 
        {
            "location": "/#simple-example", 
            "text": "{\n     name : ViewController ,\n     root :{\n         views :{\n             !redSquare :{\n                 constraints : {\n                     width height : +180 ,\n                     center : @super  24 \n                },\n                 properties :{\n                     backgroundColor : red \n                }\n            }\n        }\n    }\n}  Here I am running a blank application in the simulator side-by-side\nwith a ViewController layout described in JSON, which is loaded by the default\nView Controller. The app has connected to EverLayout Bridge \nwhich is serving layout updates every time I save the layout file.  Every time I update the JSON, the App clears and rebuilds the \nlayout with the new data.  In the example I am just changing the properties of a UIView \nto show how layouts can be designed/built without having to re-compile\nthe app.", 
            "title": "Simple Example"
        }, 
        {
            "location": "/#discussion", 
            "text": "At the moment EverLayout is more of an experiment than a solution.\nThe idea was born through frustration of Interface Builder \nand the existing alternative of clunky layout code.  The goal of this project is to find a middle ground which can offer the real-time\n'visual' approach of IB, and the flexibility and re-usability of\nlayouts described with code.", 
            "title": "Discussion"
        }, 
        {
            "location": "/#further-reading", 
            "text": "Building and distributing iOS Layouts with EverLayout", 
            "title": "Further Reading"
        }, 
        {
            "location": "/writing/", 
            "text": "Writing Layouts\n\n\nFormat \n\n\nEverLayout uses a collection of parser protocols to retrieve the pertinent layout information from your layout files.\nTheoretically, layouts can be written in any format as long as you can provide working parsers.\n\n\nThe following documentation demonstrates how to use EverLyout to write layouts for the default\nJSON parsers, however if you're interested\nin writing layouts using a different format or general structure, read \nLayout Formats\n\nto see how to write your own parsers.\n\n\nThe Layout Index \n\n\nThe layout index is the root of every layout model.\n\n\n{\n    \nname\n:\nSimpleLayout\n,\n    \nroot\n:{...},\n    \ntemplates\n:{...},\n    \ncontrollerTitle\n:\nMy App!\n,\n    \nnavigationBar\n:{...}\n}\n\n\n\n\n5 properties are currently read in the Layout Index:\n\n\n\n\nname\n The layout name. So far this is only used \nto route layout updates when developing with EverLayout Bridge.\n\n\nroot\n Layouts are built on UIViews, which become the 'root view'\nof the layout. This will most typically be your View Controller's view.\n\n\ntemplates\n EverLayout supports templates which are reusable throughout the entire layout.\nThink of these as super-classes for your view models.\n\n\ncontrollerTitle\n If your layout is built on a view contained in a \nUINavigationController\n, this\nproperty will set the title of the \nUINavigationBar\n.\n\n\nnavigationBar\n Responsible for setting other \nUINavigationBar\n properties.\n\n\n\n\nThe View Model \n\n\nThe view model contains layout data for individual UIViews.\n\n\n{\n    \ntemplate\n:\nexampleTemplate\n,\n    \nconstraints\n:{...},\n    \nproperties\n:{...},\n    \nz-index\n:\n2\n,\n    \nviews\n:{...}\n}\n\n\n\n\n\n\ntemplate\n See \nTemplates\n\n\nconstraints\n See \nWriting Constraints\n\n\nproperties\n See \nView Properties\n\n\nz-index\n See \nZ-Index\n\n\nviews\n See \nSubviews\n\n\n\n\nView Name \n\n\nEvery view in the layout (except the root view, see \nView Index\n)\nhas a name and is expressed as a subview of another view in this layout.\n\n\n{\n    ...\n    \nviews\n:{\n        \nactionButton\n:{\n            // View model data\n        }\n    }\n}\n\n\n\n\nThe key in the key-value pair is the view's name, and the value is its \nview model\n.\n\n\nIn the sample, EverLayout would scan this layout's view environment\nfor a property with the name 'actionButton'. If it finds one, it will \nmap this view model to that UIView, including adding it as \na subview.\n\n\nIf EverLayout is unable to find the view, it will attempt to find \nthe property in the environment's super-classes, before moving on. \n\n\nCreating New Views \n\n\nThe default behaviour for EverLayout is to find the view being referenced\nby scanning the properties of its view environment. However in \nsome cases you may wish to create new views from inside the layout \nfile and have them become a part of your view hierarchy.\n\n\nThis means:\n\n\n\n\nYou can create basic views to test layout ideas without having to\nre-compile (when using EverLayout Bridge).\n\n\nViews with basic functionality (like wrappers for other views)\nno longer need to be described in your code.\n\n\nMore sophisticated layout updates can be made without\nhaving to update your code and re-submit your app.\n\n\n\n\nIf your view name is prefixed with \n!\n, it will be considered a\n'new view' and created during the build process.\n\n\n{\n    \n!newWrapperView\n:{\n        // View model data\n    }\n}\n\n\n\n\nCreating New Views From UIView Subclasses \n\n\nIn addition to being able to create new views, you can also\nspecify which UIView subclass you want your new view to be.\n\n\n{\n    \n!newImageView:UIImageView\n: {\n        ...\n    }\n}\n\n\n\n\nAppend the name of your new view with \n:\n followed by \na class name. In the example EverLayout creates a new \nUIImageView.\n\n\nTo create an instance of a custom class, you must also \nspecify your application namespace, like so:\n\n\n!myNewClassInstance:MyApp.MyClassName\n\n\nWriting Constraints \n\n\nEverLayout uses AutoLayout constraints to position its elements.\nThe constraints for each view are generated during the layout\nbuild based on key-value rules in the view model.\n\n\nThe constraint arguments can be written in comprehensive and shorthand formats.\n\n\nShorthand constraints are written as key-value pairs; The key denotes which attributes \nto constrain, and the value is a representation of the layout arguments to apply\nto each of these attributes. The syntax for shorthand constraints may be difficult to read at first,\nbut after becoming familiar with this approach, layout design will be a much quicker process.\n\n\nComprehensive\n\n\n{\n    \nconstraints\n:{\n        \ntop right bottom left\n:{\n            \nto\n:\nsuper\n\n        }\n    }\n}\n\n\n\n\nShorhand\n\n\n{\n    \nconstraints\n:{\n        \ntop right bottom left\n:\n@super\n\n    }\n}\n\n\n\n\nThe example above creates 4 NSLayoutConstraints that attach\nthe left, top, right and bottom attributes of this view to \ntheir counterparts in the superview.\n\n\nComprehensive\n\n\n{\n    \nconstraints\n:{\n        \nbottom left right\n:{\n            \nto\n:\nsuper\n,\n            \ninset\n:8\n        },\n        \nheight\n:{\n            \nto\n:\nsuper\n,\n            \nmultiplier\n:0.5\n        }\n    }\n}\n\n\n\n\nShorthand\n\n\n{\n    \nconstraints\n:{\n        \nbottom left right\n:\n@super \n8\n,\n        \nheight\n:\n@super /2\n\n    }\n}\n\n\n\n\nThe second example creates constraints which tether the bottom, left and \nright edges to the superview with an 8 unit inset, and then gives this view a height \nof half the superview height.\n\n\nIn the attribute declarations (the key), and the shorthand arguments (the value), each argument\nis space separated.\n\n\nFor the left-hand statement, any NSLayoutAttribute is valid \nalong with some additional 'compound attributes'.\n\n\n\n\nedges\n Translates to \ntop\n \nleft\n \nright\n \nbottom\n\n\ncenter\n Translates to \ncenterX\n \ncenterY\n\n\nmargins\n Translates to \nmarginLeft\n \nmarginRight\n\n\n\n\nThe right-hand statement can have many arguments, each denoted by\na modifier character in shorthand.\n\n\n\n\nto\n / \n@\n Target a view in the layout / view environment\n\n\nattribute\n / \n.\n A dot separator can be added to a target name to specify \nan NSLayoutAttribute of that view to target (e.g \n@viewName.right\n)\n\n\nconstant\n / \n+\n / \n-\n A constant (positive or negative)\n\n\ninset\n / \n An inset constant, which is basically a constant where \n+\n and \n-\n are inferred from context\n\n\nmultiplier\n / \n*\n / \n/\n A multiplier or convenience divider\n\n\nidentifier\n / \n!\n Constraint identifier (for debugging)\n\n\nrelation\n / \n%\n A relation (e.g \n%\n=\n creates a 'greater than or equal to' relation). Comprehensive\nvalues are \ngte\n and \nlte\n.\n\n\npriority\n / \n$\n A constraint priority\n\n\nidentifier\n / \n!\n Give the constraints an identifier to more easily identify them in the console\n\n\n\n\nNote:\n\nEverLayout will try to infer missing constraint properties based\non the information that is supplied.\n\n\n\"width\": \"@view +12\"\n Will create a constraint with the width\nof \nview\n, plus 12 units.\n\n\n\"width\": \"+12\"\n Will create a constraint that has a width of \n12 units.\n\n\nMultiple constraints\n\n\nSince in JSON structures a key is unique, each layout attribute can only have \none constraint argument, which will cause problems if you wish to have multiple constraints\nwith different priorities or relations. To get around this the constraint arguments can be \nan array of the comprehensive and shorthand arguments described above.\n\n\n{\n    \nconstraints\n:{\n        \nwidth\n:[\n            {\n                \nconstant\n:100,\n                \npriority\n:500\n            },\n            {\n                \nconstant\n:150,\n                \npriority\n:700\n            }\n        ]\n    }\n}\n\n\n\n\nSize Classes \n\n\nA single layout file can support multiple screen sizes/orientations by allowing the activation\nand deactivation of layout constraints dependant on size classes. \n\n\nSize classes are applied as regular constraint properties as demonstrated above but will prevent \nthe activation of the constraint unless the view we're working with matches the specified size classes.\n\n\nLike the other properties, the size classes have both comprehensive and shorthand syntax.\n\n\n\n\nhorizontalSizeClass / h\n\n\nverticalSizeClass / c\n\n\n\n\nwith value options:\n\n\n\n\nregular / r\n\n\ncompact / c\n\n\n\n\n{\n    \nconstraints\n:{\n        \nwidth height\n:[\n            \n+50 hc vc\n,\n            \n+100 hr vc\n\n        ]\n    }\n}\n\n\n\n\n{\n    \nconstraints\n:{\n        \nwidth height\n:{\n            [\n                \nconstant\n:50,\n                \nhorizontalSizeClass\n:\ncompact\n,\n                \nverticalSizeClass\n:\ncompact\n\n            ],\n            [\n                \nconstant\n:100,\n                \nhorizontalSizeClass\n:\ncompact\n,\n                \nverticalSizeClass\n:\nregular\n\n            ]\n        }\n    }\n}\n\n\n\n\nThe examples above will constrain the view to a width and height of 50 points\nin a horizontal iPhone, and the same view to a width and height of 100 points in a vertical\niPhone.\n\n\nUpdating trait collection at runtime\n\n\nIf the case of having different constraints for device orientations, you'll want to be able to update\nthe layout at runtime when the trait collection updates. You can do this by overriding \n\nwillTransitionToNewCollection\n.\n\n\n    override func willTransition(to newCollection: UITraitCollection, with coordinator: UIViewControllerTransitionCoordinator) {\n        super.willTransition(to: newCollection, with: coordinator)\n\n        self.layout.updateConstraints(withTraitColelction: newCollection)\n    }\n\n\n\n\nView Properties \n\n\nSome properties of UIView (and its subclasses) have been made settable\nin the layout files. You can set these under \nproperties\n in the view model.\n\n\nThese are the properties currently available:\n\n\n UIView \n\n\n\n\nframe\n Value is passed into CGRectFromString\n\n\nbackgroundColor\n Color can be the name of the color (\nred\n) or a hex \nstring (\n#333333\n).\n\n\nhidden\n (isHidden)\n\n\ncornerRadius\n Translates to \nlayer.cornerRadius\n\n\nborderWidth\n Translates to \nlayer.borderWidth\n\n\nborderColor\n Translates to \nlayer.borderColor\n\n\nalpha\n\n\nclipToBounds\n\n\ncontentMode\n\n\nhidden\n\n\n\n\n UILabel \n\n\n\n\ntext\n\n\ntextColor\n\n\nlineBreakMode\n\n\ntextAlignment\n\n\nnumberOfLines\n\n\nfontSize\n\n\n\n\n UIButton \n\n\n\n\ntext\n Translates to a call to setTitle(...)\n\n\nfontSize\n\n\ntextColor\n Translates to a call to setTitleColor(...)\n\n\nbackgroundImage\n Translates to a call to setBackgroundImage(...)\n\n\nimage\n Translates to a call to setImage(...)\n\n\n\n\n UIImageView \n\n\n\n\nimage\n The value used is passed into UIImage(named: ...). If there is no local asset found,\nEverLayout will check if the value is a URL and attempt to load a remote image (this is helpful \nfor development, but probably not practical for production).\n\n\n\n\n UIScrollView \n\n\n\n\ncontentInset\n Value is passed into UIEdgeInsetFromString\n\n\ncontentOffset\n Value is passed in CGPointFromString\n\n\n\n\n UITextField \n\n\n\n\nplaceholder\n\n\n\n\nNavigation Bar Properties \n\n\nIf your root view is contained within a \nUINavigationController\n, you can set properties\nfor the UINavigationBar within your view index, like so:\n\n\n{\n    \nname\n:\nlayout-name\n,\n    \nroot\n:{\n        ...\n    },\n    \nnavigaitonBar\n:{\n        // Properties\n    }\n}\n\n\n\n\nThese are the available properties:\n\n\n\n\ntextColor\n\n\ntranslucent\n\n\nbackgroundColor\n\n\ntintColor\n\n\n\n\nZ-Index \n\n\nThe order in which EverLayout adds subviews is not always clear. If you\nhave views which overlap each other, the \nz-index\n can be set \nto tell EverLayout which views should be at the top.\n\n\n{\n    \nonBottom\n: {\n        \nz-index\n:\n1\n\n    },\n    \nonTop\n:{\n        \nz-index\n:\n2\n\n    }\n}\n\n\n\n\nLike in CSS, the higher the \nz-index\n the closer to the surface the view\nwill be.\n\n\nSubviews \n\n\nEvery view in the layout (except the root view) is added as a subview \nof another. Subviews are added like so:\n\n\n{\n    \nconstraints\n: {...},\n    \nproperties\n:{...},\n    \nviews\n:{\n        \nfirstSubview\n:{\n            ...\n        },\n        \nsecondSubview\n: {\n            ...\n        }\n    }\n}\n\n\n\n\nThe key is the view's name (see \nview names\n), and the value\nis the view model (see \nview model\n).\n\n\nTemplates \n\n\nA layout can have templates to be reused.\n\n\n{\n    \nname\n:\nLayoutExample\n,\n    \nroot\n:{\n        \n!buttonOne:UIButton\n:{\n            \ntemplate\n:\nbutton\n,\n            \nproperties\n:{\n                ...\n            },\n            \nconstraints\n:{\n                ...\n            }\n        },\n        \n!button2:UIButton\n:{\n            \ntemplate\n:\nbutton\n,\n            \nproperties\n:{\n                ...\n            },\n            \nconstraints\n:{\n                ...\n            }\n        }\n    },\n    \ntemplates\n:{\n        \nbutton\n:{\n            \nproperties\n:{\n                \nbackgroundColor\n:\n#333333\n\n            },\n            \nconstraints\n:{\n                \nwidth\n:\n+200\n,\n                \nheight\n:\n+40\n\n            }\n        }\n    }\n}\n\n\n\n\nIn the example the layout is creating two new buttons that are both inheriting the same properties\nfrom the template \nbutton\n. \n\n\nTemplates currently support \nproperties\n and \nconstraints\n.\n\n\nA view can inherit from multiple templates by passing the names into an array.\n\n\n{\n    \n!myView\n:{\n        \ntemplate\n:[\nfirstTemplate\n , \nsecondTemplate\n]\n    }\n}\n\n\n\n\nData Injection \n\n\n'Data Injection' is a glorified 'Find and Replace' on your source layout\ndata. You can mark 'variables' in your layout files like so: \n#{propertyName}\n\n\n{\n    \nviewName\n:{\n        \nproperties\n:{\n            \nbackgroundColor\n:\n#{color}\n\n        }\n    }\n}\n\n\n\n\nBefore building your layout:\n\n\n    self.layout?.injectData([\n        \ncolor\n:\nred\n\n    ])\n\n\n\n\nEverLayout will replace all instances of \n#{color}\n in your layout\nwith \nred\n.", 
            "title": "Writing Layouts"
        }, 
        {
            "location": "/writing/#writing-layouts", 
            "text": "", 
            "title": "Writing Layouts"
        }, 
        {
            "location": "/writing/#format", 
            "text": "EverLayout uses a collection of parser protocols to retrieve the pertinent layout information from your layout files.\nTheoretically, layouts can be written in any format as long as you can provide working parsers.  The following documentation demonstrates how to use EverLyout to write layouts for the default\nJSON parsers, however if you're interested\nin writing layouts using a different format or general structure, read  Layout Formats \nto see how to write your own parsers.", 
            "title": "Format "
        }, 
        {
            "location": "/writing/#the-layout-index", 
            "text": "The layout index is the root of every layout model.  {\n     name : SimpleLayout ,\n     root :{...},\n     templates :{...},\n     controllerTitle : My App! ,\n     navigationBar :{...}\n}  5 properties are currently read in the Layout Index:   name  The layout name. So far this is only used \nto route layout updates when developing with EverLayout Bridge.  root  Layouts are built on UIViews, which become the 'root view'\nof the layout. This will most typically be your View Controller's view.  templates  EverLayout supports templates which are reusable throughout the entire layout.\nThink of these as super-classes for your view models.  controllerTitle  If your layout is built on a view contained in a  UINavigationController , this\nproperty will set the title of the  UINavigationBar .  navigationBar  Responsible for setting other  UINavigationBar  properties.", 
            "title": "The Layout Index "
        }, 
        {
            "location": "/writing/#the-view-model", 
            "text": "The view model contains layout data for individual UIViews.  {\n     template : exampleTemplate ,\n     constraints :{...},\n     properties :{...},\n     z-index : 2 ,\n     views :{...}\n}   template  See  Templates  constraints  See  Writing Constraints  properties  See  View Properties  z-index  See  Z-Index  views  See  Subviews", 
            "title": "The View Model "
        }, 
        {
            "location": "/writing/#view-name", 
            "text": "Every view in the layout (except the root view, see  View Index )\nhas a name and is expressed as a subview of another view in this layout.  {\n    ...\n     views :{\n         actionButton :{\n            // View model data\n        }\n    }\n}  The key in the key-value pair is the view's name, and the value is its  view model .  In the sample, EverLayout would scan this layout's view environment\nfor a property with the name 'actionButton'. If it finds one, it will \nmap this view model to that UIView, including adding it as \na subview.  If EverLayout is unable to find the view, it will attempt to find \nthe property in the environment's super-classes, before moving on.", 
            "title": "View Name "
        }, 
        {
            "location": "/writing/#creating-new-views", 
            "text": "The default behaviour for EverLayout is to find the view being referenced\nby scanning the properties of its view environment. However in \nsome cases you may wish to create new views from inside the layout \nfile and have them become a part of your view hierarchy.  This means:   You can create basic views to test layout ideas without having to\nre-compile (when using EverLayout Bridge).  Views with basic functionality (like wrappers for other views)\nno longer need to be described in your code.  More sophisticated layout updates can be made without\nhaving to update your code and re-submit your app.   If your view name is prefixed with  ! , it will be considered a\n'new view' and created during the build process.  {\n     !newWrapperView :{\n        // View model data\n    }\n}", 
            "title": "Creating New Views "
        }, 
        {
            "location": "/writing/#creating-new-views-from-uiview-subclasses", 
            "text": "In addition to being able to create new views, you can also\nspecify which UIView subclass you want your new view to be.  {\n     !newImageView:UIImageView : {\n        ...\n    }\n}  Append the name of your new view with  :  followed by \na class name. In the example EverLayout creates a new \nUIImageView.  To create an instance of a custom class, you must also \nspecify your application namespace, like so:  !myNewClassInstance:MyApp.MyClassName", 
            "title": "Creating New Views From UIView Subclasses "
        }, 
        {
            "location": "/writing/#writing-constraints", 
            "text": "EverLayout uses AutoLayout constraints to position its elements.\nThe constraints for each view are generated during the layout\nbuild based on key-value rules in the view model.  The constraint arguments can be written in comprehensive and shorthand formats.  Shorthand constraints are written as key-value pairs; The key denotes which attributes \nto constrain, and the value is a representation of the layout arguments to apply\nto each of these attributes. The syntax for shorthand constraints may be difficult to read at first,\nbut after becoming familiar with this approach, layout design will be a much quicker process.", 
            "title": "Writing Constraints "
        }, 
        {
            "location": "/writing/#comprehensive", 
            "text": "{\n     constraints :{\n         top right bottom left :{\n             to : super \n        }\n    }\n}", 
            "title": "Comprehensive"
        }, 
        {
            "location": "/writing/#shorhand", 
            "text": "{\n     constraints :{\n         top right bottom left : @super \n    }\n}  The example above creates 4 NSLayoutConstraints that attach\nthe left, top, right and bottom attributes of this view to \ntheir counterparts in the superview.", 
            "title": "Shorhand"
        }, 
        {
            "location": "/writing/#comprehensive_1", 
            "text": "{\n     constraints :{\n         bottom left right :{\n             to : super ,\n             inset :8\n        },\n         height :{\n             to : super ,\n             multiplier :0.5\n        }\n    }\n}", 
            "title": "Comprehensive"
        }, 
        {
            "location": "/writing/#shorthand", 
            "text": "{\n     constraints :{\n         bottom left right : @super  8 ,\n         height : @super /2 \n    }\n}  The second example creates constraints which tether the bottom, left and \nright edges to the superview with an 8 unit inset, and then gives this view a height \nof half the superview height.  In the attribute declarations (the key), and the shorthand arguments (the value), each argument\nis space separated.  For the left-hand statement, any NSLayoutAttribute is valid \nalong with some additional 'compound attributes'.   edges  Translates to  top   left   right   bottom  center  Translates to  centerX   centerY  margins  Translates to  marginLeft   marginRight   The right-hand statement can have many arguments, each denoted by\na modifier character in shorthand.   to  /  @  Target a view in the layout / view environment  attribute  /  .  A dot separator can be added to a target name to specify \nan NSLayoutAttribute of that view to target (e.g  @viewName.right )  constant  /  +  /  -  A constant (positive or negative)  inset  /   An inset constant, which is basically a constant where  +  and  -  are inferred from context  multiplier  /  *  /  /  A multiplier or convenience divider  identifier  /  !  Constraint identifier (for debugging)  relation  /  %  A relation (e.g  % =  creates a 'greater than or equal to' relation). Comprehensive\nvalues are  gte  and  lte .  priority  /  $  A constraint priority  identifier  /  !  Give the constraints an identifier to more easily identify them in the console   Note: \nEverLayout will try to infer missing constraint properties based\non the information that is supplied.  \"width\": \"@view +12\"  Will create a constraint with the width\nof  view , plus 12 units.  \"width\": \"+12\"  Will create a constraint that has a width of \n12 units.", 
            "title": "Shorthand"
        }, 
        {
            "location": "/writing/#multiple-constraints", 
            "text": "Since in JSON structures a key is unique, each layout attribute can only have \none constraint argument, which will cause problems if you wish to have multiple constraints\nwith different priorities or relations. To get around this the constraint arguments can be \nan array of the comprehensive and shorthand arguments described above.  {\n     constraints :{\n         width :[\n            {\n                 constant :100,\n                 priority :500\n            },\n            {\n                 constant :150,\n                 priority :700\n            }\n        ]\n    }\n}", 
            "title": "Multiple constraints"
        }, 
        {
            "location": "/writing/#size-classes", 
            "text": "A single layout file can support multiple screen sizes/orientations by allowing the activation\nand deactivation of layout constraints dependant on size classes.   Size classes are applied as regular constraint properties as demonstrated above but will prevent \nthe activation of the constraint unless the view we're working with matches the specified size classes.  Like the other properties, the size classes have both comprehensive and shorthand syntax.   horizontalSizeClass / h  verticalSizeClass / c   with value options:   regular / r  compact / c   {\n     constraints :{\n         width height :[\n             +50 hc vc ,\n             +100 hr vc \n        ]\n    }\n}  {\n     constraints :{\n         width height :{\n            [\n                 constant :50,\n                 horizontalSizeClass : compact ,\n                 verticalSizeClass : compact \n            ],\n            [\n                 constant :100,\n                 horizontalSizeClass : compact ,\n                 verticalSizeClass : regular \n            ]\n        }\n    }\n}  The examples above will constrain the view to a width and height of 50 points\nin a horizontal iPhone, and the same view to a width and height of 100 points in a vertical\niPhone.", 
            "title": "Size Classes "
        }, 
        {
            "location": "/writing/#updating-trait-collection-at-runtime", 
            "text": "If the case of having different constraints for device orientations, you'll want to be able to update\nthe layout at runtime when the trait collection updates. You can do this by overriding  willTransitionToNewCollection .      override func willTransition(to newCollection: UITraitCollection, with coordinator: UIViewControllerTransitionCoordinator) {\n        super.willTransition(to: newCollection, with: coordinator)\n\n        self.layout.updateConstraints(withTraitColelction: newCollection)\n    }", 
            "title": "Updating trait collection at runtime"
        }, 
        {
            "location": "/writing/#view-properties", 
            "text": "Some properties of UIView (and its subclasses) have been made settable\nin the layout files. You can set these under  properties  in the view model.  These are the properties currently available:   UIView    frame  Value is passed into CGRectFromString  backgroundColor  Color can be the name of the color ( red ) or a hex \nstring ( #333333 ).  hidden  (isHidden)  cornerRadius  Translates to  layer.cornerRadius  borderWidth  Translates to  layer.borderWidth  borderColor  Translates to  layer.borderColor  alpha  clipToBounds  contentMode  hidden    UILabel    text  textColor  lineBreakMode  textAlignment  numberOfLines  fontSize    UIButton    text  Translates to a call to setTitle(...)  fontSize  textColor  Translates to a call to setTitleColor(...)  backgroundImage  Translates to a call to setBackgroundImage(...)  image  Translates to a call to setImage(...)    UIImageView    image  The value used is passed into UIImage(named: ...). If there is no local asset found,\nEverLayout will check if the value is a URL and attempt to load a remote image (this is helpful \nfor development, but probably not practical for production).    UIScrollView    contentInset  Value is passed into UIEdgeInsetFromString  contentOffset  Value is passed in CGPointFromString    UITextField    placeholder", 
            "title": "View Properties "
        }, 
        {
            "location": "/writing/#navigation-bar-properties", 
            "text": "If your root view is contained within a  UINavigationController , you can set properties\nfor the UINavigationBar within your view index, like so:  {\n     name : layout-name ,\n     root :{\n        ...\n    },\n     navigaitonBar :{\n        // Properties\n    }\n}  These are the available properties:   textColor  translucent  backgroundColor  tintColor", 
            "title": "Navigation Bar Properties "
        }, 
        {
            "location": "/writing/#z-index", 
            "text": "The order in which EverLayout adds subviews is not always clear. If you\nhave views which overlap each other, the  z-index  can be set \nto tell EverLayout which views should be at the top.  {\n     onBottom : {\n         z-index : 1 \n    },\n     onTop :{\n         z-index : 2 \n    }\n}  Like in CSS, the higher the  z-index  the closer to the surface the view\nwill be.", 
            "title": "Z-Index "
        }, 
        {
            "location": "/writing/#subviews", 
            "text": "Every view in the layout (except the root view) is added as a subview \nof another. Subviews are added like so:  {\n     constraints : {...},\n     properties :{...},\n     views :{\n         firstSubview :{\n            ...\n        },\n         secondSubview : {\n            ...\n        }\n    }\n}  The key is the view's name (see  view names ), and the value\nis the view model (see  view model ).", 
            "title": "Subviews "
        }, 
        {
            "location": "/writing/#templates", 
            "text": "A layout can have templates to be reused.  {\n     name : LayoutExample ,\n     root :{\n         !buttonOne:UIButton :{\n             template : button ,\n             properties :{\n                ...\n            },\n             constraints :{\n                ...\n            }\n        },\n         !button2:UIButton :{\n             template : button ,\n             properties :{\n                ...\n            },\n             constraints :{\n                ...\n            }\n        }\n    },\n     templates :{\n         button :{\n             properties :{\n                 backgroundColor : #333333 \n            },\n             constraints :{\n                 width : +200 ,\n                 height : +40 \n            }\n        }\n    }\n}  In the example the layout is creating two new buttons that are both inheriting the same properties\nfrom the template  button .   Templates currently support  properties  and  constraints .  A view can inherit from multiple templates by passing the names into an array.  {\n     !myView :{\n         template :[ firstTemplate  ,  secondTemplate ]\n    }\n}", 
            "title": "Templates "
        }, 
        {
            "location": "/writing/#data-injection", 
            "text": "'Data Injection' is a glorified 'Find and Replace' on your source layout\ndata. You can mark 'variables' in your layout files like so:  #{propertyName}  {\n     viewName :{\n         properties :{\n             backgroundColor : #{color} \n        }\n    }\n}  Before building your layout:      self.layout?.injectData([\n         color : red \n    ])  EverLayout will replace all instances of  #{color}  in your layout\nwith  red .", 
            "title": "Data Injection "
        }, 
        {
            "location": "/reading/", 
            "text": "Layout Data\n\n\n    let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource: \nViewController\n, ofType: \njson\n, inDirectory: \nLayouts\n)!) as! Data\n\n    self.layout = EverLayout(layoutData: layoutData, layoutIndexParser: LayoutIndexJSONParser())\n\n\n\n\nA layout is initialized with a \nData\n object. Generally layout \ndata would be stored in a file loaded in from the Bundle, or the layout\ncan be downloaded from a server.\n\n\nThe only requirement here is that your layout is correctly formatted for\nthe parser. By default, EverLayout uses a \nJSON\n parser,\nbut you can make your own parsers for any language by conforming\nto the different \nLayoutParser\n protocols.\n\n\nBuilding Layout\n\n\n    self.layout!.build(onView: self.view, viewEnvironment: self)\n\n\n\n\nBuilding a layout requires a root view (see \nlayout Index\n)\nand a \nView Environment\n is optional. If left nil,\nthe root view will be used as the view environment.\n\n\n Note \n\n - The instance of EverLayout should be strongly held.\nIf the layout is deallocated, EverLayout Bridge won't be able to update it.\n\n\nView Environment \n\n\nA view environment is an instance of NSObject which contains the properties\nreferenced in the layout file. For instance, in a View Controller, you would\nwant the root view of your layout to be the controller's view, but the controller\nitself is the object containing the other views in your layout.\n\n\n    class ViewController : UIViewController {\n        private var layout : EverLayout(...)\n        public let viewInLayout : UIView = UIView()\n\n        override func viewDidLoad () {\n            super.viewDidLoad()\n\n            self.layout!.build(onView: self.view, viewEnvironment: self)\n        }\n    }\n\n\n\n\n{\n    \nname\n:\nViewController\n,\n    \nroot\n:{\n        \nviews\n:{\n            \nviewInLayout\n:{\n                ...\n            }\n        }\n    }\n}\n\n\n\n\nIn the above example, EverLayout will use the ViewController as the View Environment\nand find \nviewInLayout\n as a property. During the build process it will\nadd this view to the root.\n\n\nAs EverLayout is looking for an NSObject as a View Environment, you can alternatively\nuse an NSDictionary to directly pass the views into the layout. This is\nhelpful when using loading layouts dynamically.\n\n\n    let viewEnvironment : NSDictionary = [\n        \nviewInLayout\n: UIView()\n    ]\n\n    self.layout?.build(onView: self , viewEnvironment: viewEnvironment)\n\n\n\n\n Note \n\n - \nNSDictionary\n can be used because it is a subclass of NSObject. The Swift\n \nDictionary\n is not and will not work.\n\n\n Note \n\n - Properties accessed from the View Environment must be \npublic\n, otherwise\n you will likely crash and the world will come to an end.\n\n\nView Index \n\n\nA View Index is created by the layout when it builds. The View Index keeps\ntrack of all the views created in the layout and allows you to access\nthem after the layout has successfully built.\n\n\n    let wrapperView = self.layout?.viewIndex.view(forKey: \nwrapperView\n)\n\n\n\n\nBeing able to access views from the View Index is helpful when the layout is\ncreating new views (see \nCreating Views\n)\n\n\nEverLayoutDelegate \n\n\nConform to \nEverLayoutDelegate\n and implement \n\nlayout(_ layout:EverLayout , didBuildOnView: UIView)\n\nwhich is called when a layout successfully builds on a view.\n\n\n Note \n \n - Make sure you set the \ndelegate\n before building the layout.\n\n\nUpdating Constraints \n\n\nDuring runtime you may wish to update the constant or multiplier on a constraint\ncreated in EverLayout. In \nlayoutDidBuild\n you can access these constraints in various ways.\n\n\nfunc layout(_ layout: EverLayout, didLoadOnView view: UIView) {\n    if let myView = self.layout.viewIndex.viewModel(forKey: \nmyView\n) {\n        if let heightConstraint = myView.getConstraints(forAttribute: .height).first {\n            heightConstraint.constant = 120\n        }\n    }\n}\n\n\n\n\nYou can target constraints belonging to a view model by both their attributes\nand their identifiers.", 
            "title": "Reading Layouts"
        }, 
        {
            "location": "/reading/#layout-data", 
            "text": "let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource:  ViewController , ofType:  json , inDirectory:  Layouts )!) as! Data\n\n    self.layout = EverLayout(layoutData: layoutData, layoutIndexParser: LayoutIndexJSONParser())  A layout is initialized with a  Data  object. Generally layout \ndata would be stored in a file loaded in from the Bundle, or the layout\ncan be downloaded from a server.  The only requirement here is that your layout is correctly formatted for\nthe parser. By default, EverLayout uses a  JSON  parser,\nbut you can make your own parsers for any language by conforming\nto the different  LayoutParser  protocols.", 
            "title": "Layout Data"
        }, 
        {
            "location": "/reading/#building-layout", 
            "text": "self.layout!.build(onView: self.view, viewEnvironment: self)  Building a layout requires a root view (see  layout Index )\nand a  View Environment  is optional. If left nil,\nthe root view will be used as the view environment.   Note  \n - The instance of EverLayout should be strongly held.\nIf the layout is deallocated, EverLayout Bridge won't be able to update it.", 
            "title": "Building Layout"
        }, 
        {
            "location": "/reading/#view-environment", 
            "text": "A view environment is an instance of NSObject which contains the properties\nreferenced in the layout file. For instance, in a View Controller, you would\nwant the root view of your layout to be the controller's view, but the controller\nitself is the object containing the other views in your layout.      class ViewController : UIViewController {\n        private var layout : EverLayout(...)\n        public let viewInLayout : UIView = UIView()\n\n        override func viewDidLoad () {\n            super.viewDidLoad()\n\n            self.layout!.build(onView: self.view, viewEnvironment: self)\n        }\n    }  {\n     name : ViewController ,\n     root :{\n         views :{\n             viewInLayout :{\n                ...\n            }\n        }\n    }\n}  In the above example, EverLayout will use the ViewController as the View Environment\nand find  viewInLayout  as a property. During the build process it will\nadd this view to the root.  As EverLayout is looking for an NSObject as a View Environment, you can alternatively\nuse an NSDictionary to directly pass the views into the layout. This is\nhelpful when using loading layouts dynamically.      let viewEnvironment : NSDictionary = [\n         viewInLayout : UIView()\n    ]\n\n    self.layout?.build(onView: self , viewEnvironment: viewEnvironment)   Note  \n -  NSDictionary  can be used because it is a subclass of NSObject. The Swift\n  Dictionary  is not and will not work.   Note  \n - Properties accessed from the View Environment must be  public , otherwise\n you will likely crash and the world will come to an end.", 
            "title": "View Environment "
        }, 
        {
            "location": "/reading/#view-index", 
            "text": "A View Index is created by the layout when it builds. The View Index keeps\ntrack of all the views created in the layout and allows you to access\nthem after the layout has successfully built.      let wrapperView = self.layout?.viewIndex.view(forKey:  wrapperView )  Being able to access views from the View Index is helpful when the layout is\ncreating new views (see  Creating Views )", 
            "title": "View Index "
        }, 
        {
            "location": "/reading/#everlayoutdelegate", 
            "text": "Conform to  EverLayoutDelegate  and implement  layout(_ layout:EverLayout , didBuildOnView: UIView) \nwhich is called when a layout successfully builds on a view.   Note   \n - Make sure you set the  delegate  before building the layout.", 
            "title": "EverLayoutDelegate "
        }, 
        {
            "location": "/reading/#updating-constraints", 
            "text": "During runtime you may wish to update the constant or multiplier on a constraint\ncreated in EverLayout. In  layoutDidBuild  you can access these constraints in various ways.  func layout(_ layout: EverLayout, didLoadOnView view: UIView) {\n    if let myView = self.layout.viewIndex.viewModel(forKey:  myView ) {\n        if let heightConstraint = myView.getConstraints(forAttribute: .height).first {\n            heightConstraint.constant = 120\n        }\n    }\n}  You can target constraints belonging to a view model by both their attributes\nand their identifiers.", 
            "title": "Updating Constraints "
        }, 
        {
            "location": "/formats/", 
            "text": "Formats\n\n\nIn the event that you don't want your layouts written in JSON, or that you wish\nto create your own layout format, you can create custom parsers for EverLayout by \nconforming to a few protocols.\n\n\nProtocols\n\n\n\n\nLayoutIndexParser\n\n\nLayoutViewParser\n\n\nLayoutConstraintParser\n\n\nLayoutPropertyParser\n\n\nLayoutTemplateParser\n\n\n\n\nUsing these parsers\n\n\nThe parsing of a layout always starts with its index, or the \nLayoutIndexParser\n.\nWhen a parser returns a data model, it is responsible for ensuring that the model has\naccess to its own appropriate parser.\n\n\nTo use your own parsers, you can pass an \nLayoutIndexParser\n when instantiating \nEverLayout.\n\n\n    self.layout = EverLayout(layoutData: data , indexParser: myYamlIndexParser)\n\n\n\n\nNotes\n\n\nFor general usage tips on writing a parser, check out the JSON parsers that are included:\n\n\n\n\nLayoutIndexJSONParser\n\n\nLayoutViewJSONParser\n\n\nLayoutConstraintsJSONParser\n\n\nLayoutConstraintsJSONComprehensiveParser\n\n\nLayoutPropertiesJSONParser\n\n\nLayoutTemplatesJSONParser", 
            "title": "Layout Formats"
        }, 
        {
            "location": "/formats/#formats", 
            "text": "In the event that you don't want your layouts written in JSON, or that you wish\nto create your own layout format, you can create custom parsers for EverLayout by \nconforming to a few protocols.", 
            "title": "Formats"
        }, 
        {
            "location": "/formats/#protocols", 
            "text": "LayoutIndexParser  LayoutViewParser  LayoutConstraintParser  LayoutPropertyParser  LayoutTemplateParser", 
            "title": "Protocols"
        }, 
        {
            "location": "/formats/#using-these-parsers", 
            "text": "The parsing of a layout always starts with its index, or the  LayoutIndexParser .\nWhen a parser returns a data model, it is responsible for ensuring that the model has\naccess to its own appropriate parser.  To use your own parsers, you can pass an  LayoutIndexParser  when instantiating \nEverLayout.      self.layout = EverLayout(layoutData: data , indexParser: myYamlIndexParser)", 
            "title": "Using these parsers"
        }, 
        {
            "location": "/formats/#notes", 
            "text": "For general usage tips on writing a parser, check out the JSON parsers that are included:   LayoutIndexJSONParser  LayoutViewJSONParser  LayoutConstraintsJSONParser  LayoutConstraintsJSONComprehensiveParser  LayoutPropertiesJSONParser  LayoutTemplatesJSONParser", 
            "title": "Notes"
        }, 
        {
            "location": "/bridge/", 
            "text": "Overview\n\n\nEverLayout Bridge is a small node powered simple HTTP server which monitors\nlayout files and sends them to the app when they've been updated.\n\n\nYou can get more information on EverLayout Bridge \nhere\n\n\nInstallation\n\n\nnpm install -g ever-layout-bridge\n\n\nConnecting\n\n\nWhen EverLayout Bridge is running, your app needs to make a connection\nto it. It makes most sense to make this connection in your \n\nAppDelegate\n, and also a check for \nDEBUG\n mode might be good.\n\n\n    #if DEBUG\n        EverLayoutBridge.connectToLayoutServer()\n    #endif\n\n\n\n\nOptionally, you can pass an IP Address and a Port number to this \nmethod.", 
            "title": "EverLayout Bridge"
        }, 
        {
            "location": "/bridge/#overview", 
            "text": "EverLayout Bridge is a small node powered simple HTTP server which monitors\nlayout files and sends them to the app when they've been updated.  You can get more information on EverLayout Bridge  here", 
            "title": "Overview"
        }, 
        {
            "location": "/bridge/#installation", 
            "text": "npm install -g ever-layout-bridge", 
            "title": "Installation"
        }, 
        {
            "location": "/bridge/#connecting", 
            "text": "When EverLayout Bridge is running, your app needs to make a connection\nto it. It makes most sense to make this connection in your  AppDelegate , and also a check for  DEBUG  mode might be good.      #if DEBUG\n        EverLayoutBridge.connectToLayoutServer()\n    #endif  Optionally, you can pass an IP Address and a Port number to this \nmethod.", 
            "title": "Connecting"
        }
    ]
}