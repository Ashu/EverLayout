{
    "docs": [
        {
            "location": "/", 
            "text": "EverLayout\n\n\nEverLayout translates JSON/XML data into iOS layouts which can be downloaded, reused and updated at runtime.\n\n\nFeatures\n\n\n\n\nCreate comprehensive layouts without the clumsiness of \nInterface Builder or view controllers bloated with layout code.\n\n\nDownloadable layouts - Layouts written in JSON can be downloaded\nfrom a web server, meaning an App UI can be updated without \nhaving to submit for App Review.\n\n\nBuild layouts with real-time update using a simple HTTP server (or \nEverLayout Bridge\n).\n\n\nA/B Testing - Testing multiple UIs with your users is easy\nwhen building a layout is just loading a file.\n\n\n\n\nInstallation\n\n\nCocoapods\n\n\nAdd EverLayout to your \nPodfile\n\n\nplatform :ios, '8.0'\nuse_frameworks!\npod 'Everlayout'\n\n\n\n\nCarthage\n\n\nCreate a Cartfile that lists the framework and run carthage update.\n\n\ngithub \nacrocat/EverLayout\n\n\n\n\nEverLayout Bridge\n\n\nEverLayout Bridge can be installed via Node Package Manager.\n\n\nnpm install -g ever-layout-bridge\n\n\n\n\nMore info \nhere\n\n\nUsage Example\n\n\nLayout file\n\n\n{\n    \nname\n:\nViewController\n,\n    \nroot\n:{\n        \nviews\n:{\n            \nexampleButton\n:{\n                \nconstraints\n:{\n                    \ncenter\n:\n@super\n,\n                    \nwidth\n:\n+120\n,\n                    \nheight\n:\n+80\n\n                },\n                \nproperties\n:{\n                    \ntext\n:\nTap Me!\n\n                }\n            }\n        }\n    }\n}\n\n\n\n\nSwift\n\n\nimport UIKit\nimport EverLayout\n\nclass ViewController: UIViewController {\n    private var layout : EverLayout?\n    public let exampleButton : UIButton = UIButton()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource: \nViewController\n, ofType: \njson\n, inDirectory: \nLayouts\n)!) as! Data\n        self.layout = EverLayout(layoutData: layoutData)\n        self.layout?.buildLayout(onView: self.view, viewEnvironment: self)\n    }\n}\n\n\n\n\nSimple Example\n\n\n\n\n{\n    \nname\n:\nViewController\n,\n    \nroot\n:{\n        \nviews\n:{\n            \n!redSquare\n:{\n                \nconstraints\n: {\n                    \nwidth height\n:\n+180\n,\n                    \ncenter\n:\n@super \n24\n\n                },\n                \nproperties\n:{\n                    \nbackgroundColor\n:\nred\n\n                }\n            }\n        }\n    }\n}\n\n\n\n\nHere I am running a blank application in the simulator side-by-side\nwith a ViewController layout described in JSON, which is loaded by the default\nView Controller. The app has connected to EverLayout Bridge \nwhich is serving it layout updates every time I save the layout file.\n\n\nEvery time I update the JSON, the App clears and rebuilds the \nlayout with the new data.\n\n\nIn the example I am just changing the properties of a UIView \nto show how layouts can be designed/built without having to re-compile\nthe app.\n\n\nDiscussion\n\n\nAt the moment EverLayout is more of an experiment than a solution.\nThe idea was born through frustration of Interface Builder \nand the existing alternative of clunky layout code.\n\n\nThe goal of this project is to find a middle ground which can offer the real-time\n'visual' approach of IB, and the flexibility and re-usability of\nlayouts described with code.\n\n\nFurther Reading\n\n\nBuilding and distributing iOS Layouts with EverLayout\n\n\nDependencies\n\n\nEverLayout currently uses \nSocket.IO\n\n to communicate with the EverLayout Bridge for live update.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#everlayout", 
            "text": "EverLayout translates JSON/XML data into iOS layouts which can be downloaded, reused and updated at runtime.", 
            "title": "EverLayout"
        }, 
        {
            "location": "/#features", 
            "text": "Create comprehensive layouts without the clumsiness of \nInterface Builder or view controllers bloated with layout code.  Downloadable layouts - Layouts written in JSON can be downloaded\nfrom a web server, meaning an App UI can be updated without \nhaving to submit for App Review.  Build layouts with real-time update using a simple HTTP server (or  EverLayout Bridge ).  A/B Testing - Testing multiple UIs with your users is easy\nwhen building a layout is just loading a file.", 
            "title": "Features"
        }, 
        {
            "location": "/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/#cocoapods", 
            "text": "Add EverLayout to your  Podfile  platform :ios, '8.0'\nuse_frameworks!\npod 'Everlayout'", 
            "title": "Cocoapods"
        }, 
        {
            "location": "/#carthage", 
            "text": "Create a Cartfile that lists the framework and run carthage update.  github  acrocat/EverLayout", 
            "title": "Carthage"
        }, 
        {
            "location": "/#everlayout-bridge", 
            "text": "EverLayout Bridge can be installed via Node Package Manager.  npm install -g ever-layout-bridge  More info  here", 
            "title": "EverLayout Bridge"
        }, 
        {
            "location": "/#usage-example", 
            "text": "", 
            "title": "Usage Example"
        }, 
        {
            "location": "/#layout-file", 
            "text": "{\n     name : ViewController ,\n     root :{\n         views :{\n             exampleButton :{\n                 constraints :{\n                     center : @super ,\n                     width : +120 ,\n                     height : +80 \n                },\n                 properties :{\n                     text : Tap Me! \n                }\n            }\n        }\n    }\n}", 
            "title": "Layout file"
        }, 
        {
            "location": "/#swift", 
            "text": "import UIKit\nimport EverLayout\n\nclass ViewController: UIViewController {\n    private var layout : EverLayout?\n    public let exampleButton : UIButton = UIButton()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource:  ViewController , ofType:  json , inDirectory:  Layouts )!) as! Data\n        self.layout = EverLayout(layoutData: layoutData)\n        self.layout?.buildLayout(onView: self.view, viewEnvironment: self)\n    }\n}", 
            "title": "Swift"
        }, 
        {
            "location": "/#simple-example", 
            "text": "{\n     name : ViewController ,\n     root :{\n         views :{\n             !redSquare :{\n                 constraints : {\n                     width height : +180 ,\n                     center : @super  24 \n                },\n                 properties :{\n                     backgroundColor : red \n                }\n            }\n        }\n    }\n}  Here I am running a blank application in the simulator side-by-side\nwith a ViewController layout described in JSON, which is loaded by the default\nView Controller. The app has connected to EverLayout Bridge \nwhich is serving it layout updates every time I save the layout file.  Every time I update the JSON, the App clears and rebuilds the \nlayout with the new data.  In the example I am just changing the properties of a UIView \nto show how layouts can be designed/built without having to re-compile\nthe app.", 
            "title": "Simple Example"
        }, 
        {
            "location": "/#discussion", 
            "text": "At the moment EverLayout is more of an experiment than a solution.\nThe idea was born through frustration of Interface Builder \nand the existing alternative of clunky layout code.  The goal of this project is to find a middle ground which can offer the real-time\n'visual' approach of IB, and the flexibility and re-usability of\nlayouts described with code.", 
            "title": "Discussion"
        }, 
        {
            "location": "/#further-reading", 
            "text": "Building and distributing iOS Layouts with EverLayout", 
            "title": "Further Reading"
        }, 
        {
            "location": "/#dependencies", 
            "text": "EverLayout currently uses  Socket.IO \n to communicate with the EverLayout Bridge for live update.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/writing/", 
            "text": "Writing Layouts\n\n\nFormat \n\n\nEverLayout uses parsers to translate layouts from JSON data. \n\n\nThe following documentation demonstrates how to use EverLyout to write layouts for the default\nJSON parsers, however if you're interested\nin writing layouts using a different format or general structure, read \nLayout Formats\n\nto see how to write your own parsers.\n\n\nThe Layout Index \n\n\nThe layout index is the root of every layout model.\n\n\n{\n    \nname\n:\nSimpleLayout\n,\n    \nroot\n:{...},\n    \ntemplates\n:{...}\n}\n\n\n\n\nOnly 3 properties are currently read in the Layout Index:\n\n\n\n\nname\n The layout name. So far this is only used \nto route layout updates when developing with EverLayout Bridge.\n\n\nroot\n Layouts are built on UIViews, which become the 'root view'\nof the layout I.E This is where the layout begins.\n\n\ntemplates\n EverLayout supports templates which are reusable throughout the entire layout.\n\n\n\n\nThe View Model \n\n\nThe view model contains layout data for individual UIViews.\n\n\n{\n    \nconstraints\n:{...},\n    \nproperties\n:{...},\n    \nz-index\n:\n2\n,\n    \nviews\n:{...}\n}\n\n\n\n\n\n\nconstraints\n See \nWriting Constraints\n\n\nproperties\n See \nView Properties\n\n\nz-index\n See \nZ-Index\n\n\nviews\n See \nSubviews\n\n\n\n\nView Name \n\n\nEvery view in the layout (except the root view, see \nView Index\n)\nhas a name and is expressed as a subview of another view in this layout.\n\n\n{\n    ...\n    \nviews\n:{\n        \nsubviewName\n:{\n            ...\n        }\n    }\n}\n\n\n\n\nThe key being the view's name, and the value its \nview model\n.\n\n\nGiven the sample, EverLayout would scan this layout's view environment\nfor a property with this name. If it finds one, it will \nmap this view model to that UIView, including adding it as \na subview.\n\n\nIf EverLayout is unable to find the view, it will move on.\n\n\nCreating New Views \n\n\nThe default behaviour for EverLayout is to find the view being referenced\nby scanning the properties of its view environment. However in \nsome cases you may wish to create new views from inside the layout \nfile and have them become a part of your layout hierarchy.\n\n\nThis means:\n\n\n\n\nYou can create basic views to test layout ideas without having to\nre-compile (when using EverLayout Bridge).\n\n\nViews with basic functionality (like wrappers for other views)\nno longer need to be described in your code.\n\n\nMore sophisticated layout updates can be made without\nhaving to update your code and re-submit your app.\n\n\n\n\nIf your view name is prefixed with \n!\n, it will be considered a\n'new view' and created during the layout build.\n\n\n{\n    \n!newWrapperView\n:{\n        ...\n    }\n}\n\n\n\n\nCreating New Views From UIView Subclasses \n\n\nIn addition to being able to create new views, you can also\nspecify which UIView subclass you want your new view to be.\n\n\n{\n    \n!newImageView:UIImageView\n: {\n        ...\n    }\n}\n\n\n\n\nAppend the name of your new view with \n:\n followed by \na class name. In the example EverLayout creates a new \nUIImageView.\n\n\nTo create an instance of a custom class, you must also \nspecify your application namespace, like so:\n\n\n!myNewClassInstance:MyApp.MyClassName\n\n\nWriting Constraints \n\n\nEverLayout uses AutoLayout constraints to position its elements.\nThe constraints for each view are generated during the layout\nbuild based on key-value rules in the view model.\n\n\nThe constraints are written as key-value pairs; The key denotes which attributes \nto constrain, and the value is a representation of the layout arguments to apply\nto each of these attributes.\n\n\nThe constraint arguments can be written in comprehensive and shorthand formats.\n\n\nComprehensive\n\n\n{\n    \nconstraints\n:{\n        \ntop right bottom left\n:{\n            \nto\n:\nsuper\n\n        }\n    }\n}\n\n\n\n\nShorhand\n\n\n{\n    \nconstraints\n:{\n        \ntop right bottom left\n:\n@super\n\n    }\n}\n\n\n\n\nThe example above creates 4 NSLayoutConstraints that attach\nthe left, top, right and bottom attributes of this view to \ntheir counterparts in the superview.\n\n\nComprehensive\n\n\n{\n    \nconstraints\n:{\n        \nbottom left right\n:{\n            \nto\n:\nsuper\n,\n            \ninset\n:8\n        },\n        \nheight\n:{\n            \nto\n:\nsuper\n,\n            \nmultiplier\n:0.5\n        }\n    }\n}\n\n\n\n\nShorthand\n\n\n{\n    \nconstraints\n:{\n        \nbottom left right\n:\n@super \n8\n,\n        \nheight\n:\n@super /2\n\n    }\n}\n\n\n\n\nThe second example creates constraints which tether the bottom, left and \nright edges to the superview with an 8 unit inset, and then gives this view a height \nof half the superview height.\n\n\nIn the attribute declarations (the key), and the shorthand arguments (the value), each argument\nis separated by a \" \".\n\n\nFor the left-hand statement, any NSLayoutAttribute is valid \nalong with some additional 'compound attributes'.\n\n\n\n\nedges\n Translates to \ntop\n \nleft\n \nright\n \nbottom\n\n\ncenter\n Translates to \ncenterX\n \ncenterY\n\n\n\n\nThe right-hand statement can have many arguments, each denoted by\na modifier character in shorthand.\n\n\n\n\nto\n / \n@\n Target a view in the layout / view environment\n\n\nattribute\n / \n.\n A dot separator can be added to a target name to specify \nan NSLayoutAttribute of that view to target (e.g \n@viewName.right\n)\n\n\nconstant\n / \n+\n / \n-\n A constant (positive or negative)\n\n\ninset\n / \n An inset constant, which is basically a constant where \n+\n and \n-\n are inferred from content\n\n\nmultiplier\n / \n*\n / \n/\n A multiplier or convenience divider\n\n\nidentifier\n / \n!\n Constraint identifier (for debugging)\n\n\nrelation\n / \n%\n A relation (e.g \n%\n=\n creates a 'greater than or equal to' relation). Comprehensive\nvalues are \ngte\n and \nlte\n.\n\n\npriority\n / \n$\n A constraint priority\n\n\n\n\nNote:\n\nEverLayout will try to infer missing constraint properties based\non the information that is supplied.\n\n\n\"width\": \"@view +12\"\n Will create a constraint with the width\nof \nview\n, plus 12 units.\n\n\n\"width\": \"+12\"\n Will create a constraint that has a width of \n12 units.\n\n\nMultiple constraints\n\n\nSince in JSON structures a key is unique, each layout attribute can only have \none constraint argument, which will cause problems if you wish to have multiple constraints\nwith different priorities or relations. To get around this the constraint arguments can be \nan array of the comprehensive and shorthand arguments described above.\n\n\n{\n    \nconstraints\n:{\n        \nwidth\n:[\n            {\n                \nconstant\n:100,\n                \npriority\n:500\n            },\n            {\n                \nconstant\n:150,\n                \npriority\n:700\n            }\n        ]\n    }\n}\n\n\n\n\nView Properties \n\n\nSome properties of UIView (and its subclasses) have been made settable\nin the layout files. You can set these under \nproperties\n in the view model.\n\n\nThese are the properties currently available:\n\n\n UIView \n\n\n\n\nbackgroundColor\n Color can be the name of the color (\nred\n) or a hex \nstring (\n#333333\n).\n\n\ncornerRadius\n Translates to \nlayer.cornerRadius\n\n\nborderWidth\n Translates to \nlayer.borderWidth\n\n\nborderColor\n Translates to \nlayer.borderColor\n\n\nalpha\n\n\nclipToBounds\n\n\ncontentMode\n\n\nhidden\n\n\n\n\n UILabel \n\n\n\n\ntext\n\n\ntextColor\n\n\nlineBreakMode\n\n\ntextAlignment\n\n\nnumberOfLines\n\n\nfontSize\n\n\n\n\n UIButton \n\n\n\n\ntext\n Translates to a call to setTitle(...)\n\n\ntextColor\n Translates to a call to setTitleColor(...)\n\n\nbackgroundImage\n Translates to a call to setBackgroundImage(...)\n\n\nimage\n Translates to a call to setImage(...)\n\n\n\n\n UIImageView \n\n\n\n\nimage\n The value used is passed into UIImage(named: ...). If there is no local asset found,\nEverLayout will check if the value is a URL and attempt to load a remote image (this is helpful \nfor development, but probably not practical for production).\n\n\n\n\n UIScrollView \n\n\n\n\ncontentInset\n Value is passed into UIEdgeInsetFromString\n\n\ncontentOffset\n Value is passed in CGPointFromString\n\n\n\n\n UITextField \n\n\n\n\nplaceholder\n\n\n\n\nZ-Index \n\n\nThe order in which EverLayout adds subviews is not always clear. If you\nhave views which overlap each other, the \nz-index\n can be set \nto tell EverLayout which views should be at the top.\n\n\n{\n    \nonBottom\n: {\n        \nz-index\n:\n1\n\n    },\n    \nonTop\n:{\n        \nz-index\n:\n2\n\n    }\n}\n\n\n\n\nLike in CSS, the higher the \nz-index\n the closer to the surface the view\nwill be.\n\n\nSubviews \n\n\nEvery view in the layout (except the root view) is added as a subview \nof another. Subviews are added like so:\n\n\n{\n    \nconstraints\n: {...},\n    \nproperties\n:{...},\n    \nviews\n:{\n        \nfirstSubview\n:{\n            ...\n        },\n        \nsecondSubview\n: {\n            ...\n        }\n    }\n}\n\n\n\n\nThe key is the view's name (see \nview names\n), and the value\nis the view model (see \nview model\n).\n\n\nTemplates \n\n\nA layout can have templates to be reused.\n\n\n{\n    \nname\n:\nLayoutExample\n,\n    \nroot\n:{\n        \n!buttonOne:UIButton\n:{\n            \ntemplate\n:\nbutton\n,\n            \nproperties\n:{\n                ...\n            },\n            \nconstraints\n:{\n                ...\n            }\n        },\n        \n!button2:UIButton\n:{\n            \ntemplate\n:\nbutton\n,\n            \nproperties\n:{\n                ...\n            },\n            \nconstraints\n:{\n                ...\n            }\n        }\n    },\n    \ntemplates\n:{\n        \nbutton\n:{\n            \nproperties\n:{\n                \nbackgroundColor\n:\n#333333\n\n            },\n            \nconstraints\n:{\n                \nwidth\n:\n+200\n,\n                \nheight\n:\n+40\n\n            }\n        }\n    }\n}\n\n\n\n\nIn the example the layout is creating two new buttons that are both inheriting the same properties\nfrom the template \nbutton\n. \n\n\nTemplates currently support \nproperties\n and \nconstraints\n.\n\n\nA view can inherit from multiple templates by passing the names into an array.\n\n\n{\n    \n!myView\n:{\n        \ntemplate\n:[\nfirstTemplate\n , \nsecondTemplate\n]\n    }\n}\n\n\n\n\nData Injection \n\n\n'Data Injection' is a glorified 'Find and Replace' on your source layout\ndata. You can mark 'variables' in your layout files like so:\n\n\n{\n    \nviewName\n:{\n        \nproperties\n:{\n            \nbackgroundColor\n:\n#{color}\n\n        }\n    }\n}\n\n\n\n\nBefore building your layout:\n\n\n    self.layout?.injectData([\n        \ncolor\n:\nred\n\n    ])\n\n\n\n\nEverLayout will replace all instances of \n#{color}\n in your layout\nwith \nred\n.", 
            "title": "Writing Layouts"
        }, 
        {
            "location": "/writing/#writing-layouts", 
            "text": "", 
            "title": "Writing Layouts"
        }, 
        {
            "location": "/writing/#format", 
            "text": "EverLayout uses parsers to translate layouts from JSON data.   The following documentation demonstrates how to use EverLyout to write layouts for the default\nJSON parsers, however if you're interested\nin writing layouts using a different format or general structure, read  Layout Formats \nto see how to write your own parsers.", 
            "title": "Format "
        }, 
        {
            "location": "/writing/#the-layout-index", 
            "text": "The layout index is the root of every layout model.  {\n     name : SimpleLayout ,\n     root :{...},\n     templates :{...}\n}  Only 3 properties are currently read in the Layout Index:   name  The layout name. So far this is only used \nto route layout updates when developing with EverLayout Bridge.  root  Layouts are built on UIViews, which become the 'root view'\nof the layout I.E This is where the layout begins.  templates  EverLayout supports templates which are reusable throughout the entire layout.", 
            "title": "The Layout Index "
        }, 
        {
            "location": "/writing/#the-view-model", 
            "text": "The view model contains layout data for individual UIViews.  {\n     constraints :{...},\n     properties :{...},\n     z-index : 2 ,\n     views :{...}\n}   constraints  See  Writing Constraints  properties  See  View Properties  z-index  See  Z-Index  views  See  Subviews", 
            "title": "The View Model "
        }, 
        {
            "location": "/writing/#view-name", 
            "text": "Every view in the layout (except the root view, see  View Index )\nhas a name and is expressed as a subview of another view in this layout.  {\n    ...\n     views :{\n         subviewName :{\n            ...\n        }\n    }\n}  The key being the view's name, and the value its  view model .  Given the sample, EverLayout would scan this layout's view environment\nfor a property with this name. If it finds one, it will \nmap this view model to that UIView, including adding it as \na subview.  If EverLayout is unable to find the view, it will move on.", 
            "title": "View Name "
        }, 
        {
            "location": "/writing/#creating-new-views", 
            "text": "The default behaviour for EverLayout is to find the view being referenced\nby scanning the properties of its view environment. However in \nsome cases you may wish to create new views from inside the layout \nfile and have them become a part of your layout hierarchy.  This means:   You can create basic views to test layout ideas without having to\nre-compile (when using EverLayout Bridge).  Views with basic functionality (like wrappers for other views)\nno longer need to be described in your code.  More sophisticated layout updates can be made without\nhaving to update your code and re-submit your app.   If your view name is prefixed with  ! , it will be considered a\n'new view' and created during the layout build.  {\n     !newWrapperView :{\n        ...\n    }\n}", 
            "title": "Creating New Views "
        }, 
        {
            "location": "/writing/#creating-new-views-from-uiview-subclasses", 
            "text": "In addition to being able to create new views, you can also\nspecify which UIView subclass you want your new view to be.  {\n     !newImageView:UIImageView : {\n        ...\n    }\n}  Append the name of your new view with  :  followed by \na class name. In the example EverLayout creates a new \nUIImageView.  To create an instance of a custom class, you must also \nspecify your application namespace, like so:  !myNewClassInstance:MyApp.MyClassName", 
            "title": "Creating New Views From UIView Subclasses "
        }, 
        {
            "location": "/writing/#writing-constraints", 
            "text": "EverLayout uses AutoLayout constraints to position its elements.\nThe constraints for each view are generated during the layout\nbuild based on key-value rules in the view model.  The constraints are written as key-value pairs; The key denotes which attributes \nto constrain, and the value is a representation of the layout arguments to apply\nto each of these attributes.  The constraint arguments can be written in comprehensive and shorthand formats.", 
            "title": "Writing Constraints "
        }, 
        {
            "location": "/writing/#comprehensive", 
            "text": "{\n     constraints :{\n         top right bottom left :{\n             to : super \n        }\n    }\n}", 
            "title": "Comprehensive"
        }, 
        {
            "location": "/writing/#shorhand", 
            "text": "{\n     constraints :{\n         top right bottom left : @super \n    }\n}  The example above creates 4 NSLayoutConstraints that attach\nthe left, top, right and bottom attributes of this view to \ntheir counterparts in the superview.", 
            "title": "Shorhand"
        }, 
        {
            "location": "/writing/#comprehensive_1", 
            "text": "{\n     constraints :{\n         bottom left right :{\n             to : super ,\n             inset :8\n        },\n         height :{\n             to : super ,\n             multiplier :0.5\n        }\n    }\n}", 
            "title": "Comprehensive"
        }, 
        {
            "location": "/writing/#shorthand", 
            "text": "{\n     constraints :{\n         bottom left right : @super  8 ,\n         height : @super /2 \n    }\n}  The second example creates constraints which tether the bottom, left and \nright edges to the superview with an 8 unit inset, and then gives this view a height \nof half the superview height.  In the attribute declarations (the key), and the shorthand arguments (the value), each argument\nis separated by a \" \".  For the left-hand statement, any NSLayoutAttribute is valid \nalong with some additional 'compound attributes'.   edges  Translates to  top   left   right   bottom  center  Translates to  centerX   centerY   The right-hand statement can have many arguments, each denoted by\na modifier character in shorthand.   to  /  @  Target a view in the layout / view environment  attribute  /  .  A dot separator can be added to a target name to specify \nan NSLayoutAttribute of that view to target (e.g  @viewName.right )  constant  /  +  /  -  A constant (positive or negative)  inset  /   An inset constant, which is basically a constant where  +  and  -  are inferred from content  multiplier  /  *  /  /  A multiplier or convenience divider  identifier  /  !  Constraint identifier (for debugging)  relation  /  %  A relation (e.g  % =  creates a 'greater than or equal to' relation). Comprehensive\nvalues are  gte  and  lte .  priority  /  $  A constraint priority   Note: \nEverLayout will try to infer missing constraint properties based\non the information that is supplied.  \"width\": \"@view +12\"  Will create a constraint with the width\nof  view , plus 12 units.  \"width\": \"+12\"  Will create a constraint that has a width of \n12 units.", 
            "title": "Shorthand"
        }, 
        {
            "location": "/writing/#multiple-constraints", 
            "text": "Since in JSON structures a key is unique, each layout attribute can only have \none constraint argument, which will cause problems if you wish to have multiple constraints\nwith different priorities or relations. To get around this the constraint arguments can be \nan array of the comprehensive and shorthand arguments described above.  {\n     constraints :{\n         width :[\n            {\n                 constant :100,\n                 priority :500\n            },\n            {\n                 constant :150,\n                 priority :700\n            }\n        ]\n    }\n}", 
            "title": "Multiple constraints"
        }, 
        {
            "location": "/writing/#view-properties", 
            "text": "Some properties of UIView (and its subclasses) have been made settable\nin the layout files. You can set these under  properties  in the view model.  These are the properties currently available:   UIView    backgroundColor  Color can be the name of the color ( red ) or a hex \nstring ( #333333 ).  cornerRadius  Translates to  layer.cornerRadius  borderWidth  Translates to  layer.borderWidth  borderColor  Translates to  layer.borderColor  alpha  clipToBounds  contentMode  hidden    UILabel    text  textColor  lineBreakMode  textAlignment  numberOfLines  fontSize    UIButton    text  Translates to a call to setTitle(...)  textColor  Translates to a call to setTitleColor(...)  backgroundImage  Translates to a call to setBackgroundImage(...)  image  Translates to a call to setImage(...)    UIImageView    image  The value used is passed into UIImage(named: ...). If there is no local asset found,\nEverLayout will check if the value is a URL and attempt to load a remote image (this is helpful \nfor development, but probably not practical for production).    UIScrollView    contentInset  Value is passed into UIEdgeInsetFromString  contentOffset  Value is passed in CGPointFromString    UITextField    placeholder", 
            "title": "View Properties "
        }, 
        {
            "location": "/writing/#z-index", 
            "text": "The order in which EverLayout adds subviews is not always clear. If you\nhave views which overlap each other, the  z-index  can be set \nto tell EverLayout which views should be at the top.  {\n     onBottom : {\n         z-index : 1 \n    },\n     onTop :{\n         z-index : 2 \n    }\n}  Like in CSS, the higher the  z-index  the closer to the surface the view\nwill be.", 
            "title": "Z-Index "
        }, 
        {
            "location": "/writing/#subviews", 
            "text": "Every view in the layout (except the root view) is added as a subview \nof another. Subviews are added like so:  {\n     constraints : {...},\n     properties :{...},\n     views :{\n         firstSubview :{\n            ...\n        },\n         secondSubview : {\n            ...\n        }\n    }\n}  The key is the view's name (see  view names ), and the value\nis the view model (see  view model ).", 
            "title": "Subviews "
        }, 
        {
            "location": "/writing/#templates", 
            "text": "A layout can have templates to be reused.  {\n     name : LayoutExample ,\n     root :{\n         !buttonOne:UIButton :{\n             template : button ,\n             properties :{\n                ...\n            },\n             constraints :{\n                ...\n            }\n        },\n         !button2:UIButton :{\n             template : button ,\n             properties :{\n                ...\n            },\n             constraints :{\n                ...\n            }\n        }\n    },\n     templates :{\n         button :{\n             properties :{\n                 backgroundColor : #333333 \n            },\n             constraints :{\n                 width : +200 ,\n                 height : +40 \n            }\n        }\n    }\n}  In the example the layout is creating two new buttons that are both inheriting the same properties\nfrom the template  button .   Templates currently support  properties  and  constraints .  A view can inherit from multiple templates by passing the names into an array.  {\n     !myView :{\n         template :[ firstTemplate  ,  secondTemplate ]\n    }\n}", 
            "title": "Templates "
        }, 
        {
            "location": "/writing/#data-injection", 
            "text": "'Data Injection' is a glorified 'Find and Replace' on your source layout\ndata. You can mark 'variables' in your layout files like so:  {\n     viewName :{\n         properties :{\n             backgroundColor : #{color} \n        }\n    }\n}  Before building your layout:      self.layout?.injectData([\n         color : red \n    ])  EverLayout will replace all instances of  #{color}  in your layout\nwith  red .", 
            "title": "Data Injection "
        }, 
        {
            "location": "/reading/", 
            "text": "Layout Data\n\n\n    let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource: \nViewController\n, ofType: \njson\n, inDirectory: \nLayouts\n)!) as! Data\n\n    self.layout = EverLayout(layoutData: layoutData, layoutIndexParser: LayoutIndexJSONParser())\n\n\n\n\nA layout is initialized with a \nData\n object. Generally layout \ndata would be stored in a file a loaded in from the Bundle, or the layout\ncan be downloaded from a server.\n\n\nThe only requirement here is that your layout is correctly formatted for\nthe parser. By default, EverLayout uses a \nJSON\n parser,\nbut you can make your own parsers for any language by conforming\nto the different \nLayoutParser\n protocols.\n\n\nBuilding Layout\n\n\n    self.layout!.buildLayout(onView: self.view, viewEnvironment: self)\n\n\n\n\nBuilding a layout requires a root view (see \nlayout Index\n)\nand a \nView Environment\n is optional. If left nil,\nthe root view will be used as the view environment.\n\n\n Note \n\n - The instance of EverLayout should be strongly held.\nIf the layout is deallocated, EverLayout Bridge won't be able to update it.\n\n\nView Environment \n\n\nA view environment is an instance of NSObject which contains the properties\nreferenced in the layout file. For instance, in a View Controller, you would\nwant the root view of your layout to be the controller's view, but the controller\nitself is the object containing the other views in your layout.\n\n\n    class ViewController : UIViewController\n    {\n        private var layout : EverLayout(...)\n        public let viewInLayout : UIView = UIView()\n\n        override func viewDidLoad ()\n        {\n            super.viewDidLoad()\n\n            self.layout!.buildLayout(onView: self.view, viewEnvironment: self)\n        }\n    }\n\n\n\n\n{\n    \nname\n:\nViewController\n,\n    \nroot\n:{\n        \nviews\n:{\n            \nviewInLayout\n:{\n                ...\n            }\n        }\n    }\n}\n\n\n\n\nIn the above example, EverLayout will use the ViewController as the View Environment\nand find \nviewInLayout\n as a property. During the build process it will\nadd this view to the root.\n\n\n    let viewEnvironment : NSDictionary = [\n        \nviewInLayout\n: UIView()\n    ]\n\n    self.layout?.buildLayout(onView: self , viewEnvironment: viewEnvironment)\n\n\n\n\nAs EverLayout is looking for an NSObject as a View Environment, you can alternatively\nuse an NSDictionary to directly pass the views into the layout. This is\nhelpful when using sub-layouts.\n\n\n Note \n\n - \nNSDictionary\n can be used because it is a subclass of NSObject. The Swift\n \nDictionary\n is not and will not work.\n\n\n Note \n\n - Properties accessed from the View Environment must be \npublic\n, otherwise\n you will likely face a crash.\n\n\nView Index \n\n\nA View Index is created by the layout when it builds. The View Index keeps\ntrack of all the views created in the layout and allows you to access\nthem after the layout has successfully built.\n\n\n    let wrapperView = self.layout?.viewIndex.view(forKey: \nwrapperView\n)\n\n\n\n\nBeing able to access views from the View Index is helpful when the layout is\ncreating new views (see \nCreating Views\n)\n\n\nEverLayoutDelegate \n\n\nConform to \nEverLayoutDelegate\n and implement \n\nlayout(_ layout:EverLayout , didBuildOnView: UIView)\n\nwhich is called when a layout successfully builds on a view.\n\n\n Note \n \n - Make sure you set the \ndelegate\n before building the layout.", 
            "title": "Reading Layouts"
        }, 
        {
            "location": "/reading/#layout-data", 
            "text": "let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource:  ViewController , ofType:  json , inDirectory:  Layouts )!) as! Data\n\n    self.layout = EverLayout(layoutData: layoutData, layoutIndexParser: LayoutIndexJSONParser())  A layout is initialized with a  Data  object. Generally layout \ndata would be stored in a file a loaded in from the Bundle, or the layout\ncan be downloaded from a server.  The only requirement here is that your layout is correctly formatted for\nthe parser. By default, EverLayout uses a  JSON  parser,\nbut you can make your own parsers for any language by conforming\nto the different  LayoutParser  protocols.", 
            "title": "Layout Data"
        }, 
        {
            "location": "/reading/#building-layout", 
            "text": "self.layout!.buildLayout(onView: self.view, viewEnvironment: self)  Building a layout requires a root view (see  layout Index )\nand a  View Environment  is optional. If left nil,\nthe root view will be used as the view environment.   Note  \n - The instance of EverLayout should be strongly held.\nIf the layout is deallocated, EverLayout Bridge won't be able to update it.", 
            "title": "Building Layout"
        }, 
        {
            "location": "/reading/#view-environment", 
            "text": "A view environment is an instance of NSObject which contains the properties\nreferenced in the layout file. For instance, in a View Controller, you would\nwant the root view of your layout to be the controller's view, but the controller\nitself is the object containing the other views in your layout.      class ViewController : UIViewController\n    {\n        private var layout : EverLayout(...)\n        public let viewInLayout : UIView = UIView()\n\n        override func viewDidLoad ()\n        {\n            super.viewDidLoad()\n\n            self.layout!.buildLayout(onView: self.view, viewEnvironment: self)\n        }\n    }  {\n     name : ViewController ,\n     root :{\n         views :{\n             viewInLayout :{\n                ...\n            }\n        }\n    }\n}  In the above example, EverLayout will use the ViewController as the View Environment\nand find  viewInLayout  as a property. During the build process it will\nadd this view to the root.      let viewEnvironment : NSDictionary = [\n         viewInLayout : UIView()\n    ]\n\n    self.layout?.buildLayout(onView: self , viewEnvironment: viewEnvironment)  As EverLayout is looking for an NSObject as a View Environment, you can alternatively\nuse an NSDictionary to directly pass the views into the layout. This is\nhelpful when using sub-layouts.   Note  \n -  NSDictionary  can be used because it is a subclass of NSObject. The Swift\n  Dictionary  is not and will not work.   Note  \n - Properties accessed from the View Environment must be  public , otherwise\n you will likely face a crash.", 
            "title": "View Environment "
        }, 
        {
            "location": "/reading/#view-index", 
            "text": "A View Index is created by the layout when it builds. The View Index keeps\ntrack of all the views created in the layout and allows you to access\nthem after the layout has successfully built.      let wrapperView = self.layout?.viewIndex.view(forKey:  wrapperView )  Being able to access views from the View Index is helpful when the layout is\ncreating new views (see  Creating Views )", 
            "title": "View Index "
        }, 
        {
            "location": "/reading/#everlayoutdelegate", 
            "text": "Conform to  EverLayoutDelegate  and implement  layout(_ layout:EverLayout , didBuildOnView: UIView) \nwhich is called when a layout successfully builds on a view.   Note   \n - Make sure you set the  delegate  before building the layout.", 
            "title": "EverLayoutDelegate "
        }, 
        {
            "location": "/formats/", 
            "text": "Formats\n\n\nIn the event that you don't want your layouts written in JSON, or that you wish\nto create your own layout format, you can create custom parsers for EverLayout by \nconforming to a few protocols.\n\n\nProtocols\n\n\n\n\nLayoutIndexParser\n\n\nLayoutViewParser\n\n\nLayoutConstraintParser\n\n\nLayoutPropertyParser\n\n\nLayoutTemplateParser\n\n\n\n\nUsing these parsers\n\n\nEverLayout can be instantiated with a configuration argument which specifies which parsers to\nuse.\n\n\nself.layout = EverLayout(layoutData: layoutData, parserConfiguration: EverLayoutConfiguration(\n            indexParser: LayoutIndexXMLParser(),\n            viewParser: LayoutViewXMLParser(),\n            constraintParser: LayoutConstraintXMLParser(),\n            propertyParser: LayoutPropertyXMLParser()))\nself.layout.buildLayout(onView: self.view, viewEnvironment: self)\n\n\n\n\n\nNotes\n\n\nFor general usage tips on writing a parser, check out the JSON parsers that are included:\n\n\n\n\nLayoutIndexJSONParser\n\n\nLayoutViewJSONParser\n\n\nLayoutConstraintsJSONParser\n\n\nLayoutConstraintsJSONComprehensiveParser\n\n\nLayoutPropertiesJSONParser\n\n\nLayoutTemplatesJSONParser", 
            "title": "Layout Formats"
        }, 
        {
            "location": "/formats/#formats", 
            "text": "In the event that you don't want your layouts written in JSON, or that you wish\nto create your own layout format, you can create custom parsers for EverLayout by \nconforming to a few protocols.", 
            "title": "Formats"
        }, 
        {
            "location": "/formats/#protocols", 
            "text": "LayoutIndexParser  LayoutViewParser  LayoutConstraintParser  LayoutPropertyParser  LayoutTemplateParser", 
            "title": "Protocols"
        }, 
        {
            "location": "/formats/#using-these-parsers", 
            "text": "EverLayout can be instantiated with a configuration argument which specifies which parsers to\nuse.  self.layout = EverLayout(layoutData: layoutData, parserConfiguration: EverLayoutConfiguration(\n            indexParser: LayoutIndexXMLParser(),\n            viewParser: LayoutViewXMLParser(),\n            constraintParser: LayoutConstraintXMLParser(),\n            propertyParser: LayoutPropertyXMLParser()))\nself.layout.buildLayout(onView: self.view, viewEnvironment: self)", 
            "title": "Using these parsers"
        }, 
        {
            "location": "/formats/#notes", 
            "text": "For general usage tips on writing a parser, check out the JSON parsers that are included:   LayoutIndexJSONParser  LayoutViewJSONParser  LayoutConstraintsJSONParser  LayoutConstraintsJSONComprehensiveParser  LayoutPropertiesJSONParser  LayoutTemplatesJSONParser", 
            "title": "Notes"
        }, 
        {
            "location": "/bridge/", 
            "text": "Overview\n\n\nEverLayout Bridge is a small node powered simple HTTP server which monitors\nlayout files and sends them to the app when they've been updated.\n\n\nYou can get more information on EverLayout Bridge \nhere\n\n\nInstallation\n\n\nnpm install -g ever-layout-bridge\n\n\nConnecting\n\n\nWhen EverLayout Bridge is running, your app needs to make a connection\nto it. It makes most sense to make this connection in your \n\nAppDelegate\n, and also a check for \nDEBUG\n mode might be good.\n\n\n    #if DEBUG\n        EverLayoutBridge.connectToLayoutServer()\n    #endif\n\n\n\n\nOptionally, you can pass an IP Address and a Port number to this \nmethod.", 
            "title": "EverLayout Bridge"
        }, 
        {
            "location": "/bridge/#overview", 
            "text": "EverLayout Bridge is a small node powered simple HTTP server which monitors\nlayout files and sends them to the app when they've been updated.  You can get more information on EverLayout Bridge  here", 
            "title": "Overview"
        }, 
        {
            "location": "/bridge/#installation", 
            "text": "npm install -g ever-layout-bridge", 
            "title": "Installation"
        }, 
        {
            "location": "/bridge/#connecting", 
            "text": "When EverLayout Bridge is running, your app needs to make a connection\nto it. It makes most sense to make this connection in your  AppDelegate , and also a check for  DEBUG  mode might be good.      #if DEBUG\n        EverLayoutBridge.connectToLayoutServer()\n    #endif  Optionally, you can pass an IP Address and a Port number to this \nmethod.", 
            "title": "Connecting"
        }
    ]
}