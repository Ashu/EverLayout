{
    "docs": [
        {
            "location": "/", 
            "text": "Overview\n\n\nEverLayout is a layout building tool for iOS. Layouts described\nin JSON are parsed, interpreted and built at runtime.\n\n\n Why: \n\n\n\n\nCreate comprehensive layouts without the clumsiness of \nInterface Builder or view controllers bloated with layout code.\n\n\nDownloadable layouts - Layouts written in JSON can be downloaded\nfrom a web server, meaning an App UI can be updated without \nhaving to submit for App Review.\n\n\nBuild layouts with real-time update using a simple HTTP server (or \nEverLayout Bridge\n).\n\n\nA/B Testing - Testing multiple UIs with your users is easy\nwhen building a layout is just loading a file.\n\n\n\n\nInstallation\n\n\nEverLayout can be installed with CocoaPods.\n\n\npod 'EverLayout'\n\n\nEverLayout Bridge is installed with Node Package Manager\n\n\nnpm install -g ever-layout-bridge\n\n\nMore information on EverLayout Bridge \nhere\n\n\nSimple Example\n\n\n\n\n{\n    \nname\n:\nViewController\n,\n    \nroot\n:{\n        \nviews\n:{\n            \n!redSquare\n:{\n                \nconstraints\n: {\n                    \nwidth height\n:\n+180\n,\n                    \ncenter\n:\n@super \n24\n\n                },\n                \nproperties\n:{\n                    \nbackgroundColor\n:\nred\n\n                }\n            }\n        }\n    }\n}\n\n\n\n\nHere I am running a blank application in the simulator side-by-side\nwith a ViewController layout described in JSON, which is loaded by the default\nView Controller. The app has connected to EverLayout Bridge \nwhich is serving it layout updates every time I save the layout file.\n\n\nEvery time I update the JSON, the App clears and rebuilds the \nlayout with the new data.\n\n\nIn the example I am just changing the properties of a UIView \nto show how layouts can be designed/built without having to re-compile\nthe app.\n\n\nDiscussion\n\n\nAt the moment EverLayout is more of an experiment than a solution.\nThe idea was born through frustration of Interface Builder \nand the existing alternative of clunky layout code.\n\n\nThe goal of this project is to find a middle ground which can offer the real-time\n'visual' approach of IB, and the flexibility and re-usability of\nlayouts described with code.\n\n\nDependencies\n\n\nAt the moment EverLayout uses \nSwiftyJSON\n to parse JSON files, and \nSocket.IO\n for communication with EverLayout Bridge.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#overview", 
            "text": "EverLayout is a layout building tool for iOS. Layouts described\nin JSON are parsed, interpreted and built at runtime.   Why:    Create comprehensive layouts without the clumsiness of \nInterface Builder or view controllers bloated with layout code.  Downloadable layouts - Layouts written in JSON can be downloaded\nfrom a web server, meaning an App UI can be updated without \nhaving to submit for App Review.  Build layouts with real-time update using a simple HTTP server (or  EverLayout Bridge ).  A/B Testing - Testing multiple UIs with your users is easy\nwhen building a layout is just loading a file.", 
            "title": "Overview"
        }, 
        {
            "location": "/#installation", 
            "text": "EverLayout can be installed with CocoaPods.  pod 'EverLayout'  EverLayout Bridge is installed with Node Package Manager  npm install -g ever-layout-bridge  More information on EverLayout Bridge  here", 
            "title": "Installation"
        }, 
        {
            "location": "/#simple-example", 
            "text": "{\n     name : ViewController ,\n     root :{\n         views :{\n             !redSquare :{\n                 constraints : {\n                     width height : +180 ,\n                     center : @super  24 \n                },\n                 properties :{\n                     backgroundColor : red \n                }\n            }\n        }\n    }\n}  Here I am running a blank application in the simulator side-by-side\nwith a ViewController layout described in JSON, which is loaded by the default\nView Controller. The app has connected to EverLayout Bridge \nwhich is serving it layout updates every time I save the layout file.  Every time I update the JSON, the App clears and rebuilds the \nlayout with the new data.  In the example I am just changing the properties of a UIView \nto show how layouts can be designed/built without having to re-compile\nthe app.", 
            "title": "Simple Example"
        }, 
        {
            "location": "/#discussion", 
            "text": "At the moment EverLayout is more of an experiment than a solution.\nThe idea was born through frustration of Interface Builder \nand the existing alternative of clunky layout code.  The goal of this project is to find a middle ground which can offer the real-time\n'visual' approach of IB, and the flexibility and re-usability of\nlayouts described with code.", 
            "title": "Discussion"
        }, 
        {
            "location": "/#dependencies", 
            "text": "At the moment EverLayout uses  SwiftyJSON  to parse JSON files, and  Socket.IO  for communication with EverLayout Bridge.", 
            "title": "Dependencies"
        }, 
        {
            "location": "/writing/", 
            "text": "JSON \n\n\nEverLayout is bundled with parsers to translate \nJSON structures in UIView hierarchies. JSON was the data structure\nof choice because of its wide popularity, however if you do not wish\nto use JSON you can easily implement your own data language \nby conforming to the \nLayoutParser\n protocols. \n\n\nNevertheless, the following explanation of the JSON implementation\nwill demonstrate how EverLayout understands layouts.\n\n\n Note \n - Even though Numbers and Bools are valid data types in JSON, \nEverLayout currently only recognizes String values. This may be updated in the \nfuture.\n\n\nThe Layout Index \n\n\nThe layout index is the root of every layout model.\n\n\n{\n    \nname\n:\nSimpleLayout\n,\n    \nroot\n:{...},\n    \nlayouts\n:{...}\n}\n\n\n\n\nOnly 3 properties are currently read in the Layout Index:\n\n\n\n\nname\n The layout name. So far this is only used \nto route layout updates when developing with EverLayout Bridge.\n\n\nroot\n Layouts are built on UIViews, which become the 'root view'\nof the layout I.E This is where the layout begins.\n\n\nlayouts\n EverLayout supports \nsub-layouts\n\n\n\n\nThe View Model \n\n\nThe view model contains layout data for individual UIViews.\n\n\n{\n    \nconstraints\n:{...},\n    \nproperties\n:{...},\n    \nz-index\n:\n2\n,\n    \nviews\n:{...}\n}\n\n\n\n\n\n\nconstraints\n See \nWriting Constraints\n\n\nproperties\n See \nView Properties\n\n\nz-index\n See \nZ-Index\n\n\nviews\n See \nSubviews\n\n\n\n\nView Name \n\n\nEvery view in the layout (except the root view, see \nView Index\n)\nhas a name and is expressed as a subview of another view in this layout.\n\n\n{\n    ...\n    \nviews\n:{\n        \nsubviewName\n:{\n            ...\n        }\n    }\n}\n\n\n\n\nThe key being the view's name, and the value its \nview model\n.\n\n\nGiven the sample, EverLayout would scan this layout's view environment\nfor a property with this name. If it finds one, it will \nmap this view model to that UIView, including adding it as \na subview.\n\n\nIf EverLayout is unable to find the view, it will move on.\n\n\nCreating New Views \n\n\nThe default behaviour for EverLayout is to find the view being referenced\nby scanning the properties of its view environment. However in \nsome cases you may wish to create new views from inside the layout \nfile and have them become a part of your layout hierarchy.\n\n\nThis means:\n\n\n\n\nYou can create basic views to test layout ideas without having to\nre-compile (when using EverLayout Bridge).\n\n\nViews with basic functionality (like wrappers for other views)\nno longer need to be described in your code.\n\n\nMore sophisticated layout updates can be made without\nhaving to update your code and re-submit your app.\n\n\n\n\nIf your view name is prefixed with \n!\n, it will be considered a\n'new view' and created during the layout build.\n\n\n{\n    \n!newWrapperView\n:{\n        ...\n    }\n}\n\n\n\n\nCreating New Views From UIView Subclasses \n\n\nIn addition to being able to create new views, you can also\nspecify which UIView subclass you want your new view to be.\n\n\n{\n    \n!newImageView:UIImageView\n: {\n        ...\n    }\n}\n\n\n\n\nAppend the name of your new view with \n:\n followed by \na class name. In the example EverLayout creates a new \nUIImageView.\n\n\nTo create an instance of a custom class, you must also \nspecify your application bundle ID, like so:\n\n\n!myNewClassInstance:MyApp.MyClassName\n\n\nWriting Constraints \n\n\nEverLayout uses AutoLayout constraints to position its elements.\nThe constraints for each view are generated during the layout\nbuild based on key-value rules in the view model.\n\n\nThe format of these constraint rules may not immediately make sense,\nand might take a while to get used to. They're based on ideas\ntaken from \nSnapKit\n.\n\n\n{\n    \nconstraints\n:{\n        \ntop right bottom left\n:\n@super\n\n    }\n}\n\n\n\n\nThe example above creates 4 NSLayoutConstraints that attach\nthe left, top, right and bottom attributes of this view to \ntheir counterparts in the superview.\n\n\n{\n    \nconstraints\n:{\n        \nbottom left right\n:\n@super \n8\n,\n        \nheight\n:\n@super /2\n\n    }\n}\n\n\n\n\nThe second example creates constraints which tether the bottom, left and \nright edges to the superview with an 8 unit inset, and then gives this view a height \nof half the superview height.\n\n\nEach rule is broken into left-hand and right-hand statements (key and value). Both \nstatements contain arguments separated by a space \" \".\n\n\nFor the left-hand statement, any NSLayoutAttribute is valid \nalong with some additional 'compound attributes'.\n\n\n\n\nedges\n Translates to \ntop\n \nleft\n \nright\n \nbottom\n\n\ncenter\n Translates to \ncenterX\n \ncenterY\n\n\n\n\nThe right-hand statement can have many arguments, each denoted by\na modifier character.\n\n\n\n\n@\n Target a view in the layout / view environment\n\n\n.\n A dot separator can be added to a target name to specify \nan NSLayoutAttribute of that view to target (e.g \n@viewName.right\n)\n\n\n+\n A positive constant\n\n\n-\n A negative constant\n\n\n A inset constant, which is basically a constant where \n+\n and \n-\n are inferred from content\n\n\n*\n A multiplier\n\n\n/\n A divider\n\n\n!\n Constraint identifier (for debugging)\n\n\n%\n A relation (e.g \n%\n=\n creates a 'greater than or equal to' relation)\n\n\n$\n A constraint priority\n\n\n\n\nNote:\n\nEverLayout will try to infer missing constraint properties based\non the information that is supplied.\n\n\n\"width\": \"@view +12\"\n Will create a constraint with the width\nof \nview\n, plus 12 units.\n\n\n\"width\": \"+12\"\n Will create a constraint that has a width of \n12 units.\n\n\nView Properties \n\n\nSome properties of UIView (and its subclasses) have been made settable\nin the layout files. You can set these under \nproperties\n in the view model.\n\n\nThese are the properties currently available:\n\n\n UIView \n\n\n\n\nbackgroundColor\n Color can be the name of the color (\nred\n) or a hex \nstring (\n#333333\n).\n\n\ncornerRadius\n Translates to \nlayer.cornerRadius\n\n\nborderWidth\n Translates to \nlayer.borderWidth\n\n\nborderColor\n Translates to \nlayer.borderColor\n\n\nalpha\n\n\nclipToBounds\n\n\ncontentMode\n\n\n\n\n UILabel \n\n\n\n\ntext\n\n\ntextColor\n\n\nlineBreakMode\n\n\ntextAlignment\n\n\nnumberOfLines\n\n\nfontSize\n\n\n\n\n UIButton \n\n\n\n\ntext\n Translates to a call to setTitle(...)\n\n\ntextColor\n Translates to a call to setTitleColor(...)\n\n\nbackgroundImage\n Translates to a call to setBackgroundImage(...)\n\n\nimage\n Translates to a call to setImage(...)\n\n\n\n\n UIImageView \n\n\n\n\nimage\n The value used is passed into UIImage(named: ...)\n\n\n\n\n UIScrollView \n\n\n\n\ncontentInset\n Value is passed into UIEdgeInsetFromString\n\n\ncontentOffset\n Value is passed in CGPointFromString\n\n\n\n\nZ-Index \n\n\nThe order in which EverLayout adds subviews is not always clear. If you\nhave views which overlap each other, the \nz-index\n can be set \nto tell EverLayout which views should be at the top.\n\n\n{\n    \nonBottom\n: {\n        \nz-index\n:\n1\n\n    },\n    \nonTop\n:{\n        \nz-index\n:\n2\n\n    }\n}\n\n\n\n\nLike in CSS, the higher the \nz-index\n the closer to the surface the view\nwill be.\n\n\nSubviews \n\n\nEvery view in the layout (except the root view) is added as a subview \nof another. Subviews are added like so:\n\n\n{\n    \nconstraints\n: {...},\n    \nproperties\n:{...},\n    \nviews\n:{\n        \nfirstSubview\n:{\n            ...\n        },\n        \nsecondSubview\n: {\n            ...\n        }\n    }\n}\n\n\n\n\nThe key is the view's name (see \nview names\n), and the value\nis the view model (see \nview model\n).\n\n\nSublayouts \n\n\nAn EverLayout can have 'sub-layouts'.\n\n\n{\n    \nname\n:\nMainLayoutName\n,\n    \nroot\n:{...},\n    \nlayouts\n:{\n        \nexampleSubLayout\n:{\n            \nroot\n: {...}\n        },\n        \nsecondSubLayout\n:{\n            \nroot\n: {...}\n        }\n    }\n}\n\n\n\n\nA sub-layout has mostly the same structure as a regular layout,\nexcept its name is its key. Technically sub-layouts can also have sub-layouts,\nalthough I can't say I've actually tried this.\n\n\nFor more info on using sub-layouts, see \nReading Layouts\n.\n\n\nData Injection \n\n\n'Data Injection' is a glorified 'Find and Replace' on your source layout\ndata. You can mark 'variables' in your layout files like so:\n\n\n{\n    \nviewName\n:{\n        \nproperties\n:{\n            \nbackgroundColor\n:\n#{color}\n\n        }\n    }\n}\n\n\n\n\nBefore building your layout:\n\n\n    self.layout?.injectData([\n        \ncolor\n:\nred\n\n    ])\n\n\n\n\nEverLayout will replace all instances of \n#{color}\n in your layout\nwith \nred\n.", 
            "title": "Writing Layouts"
        }, 
        {
            "location": "/writing/#json", 
            "text": "EverLayout is bundled with parsers to translate \nJSON structures in UIView hierarchies. JSON was the data structure\nof choice because of its wide popularity, however if you do not wish\nto use JSON you can easily implement your own data language \nby conforming to the  LayoutParser  protocols.   Nevertheless, the following explanation of the JSON implementation\nwill demonstrate how EverLayout understands layouts.   Note   - Even though Numbers and Bools are valid data types in JSON, \nEverLayout currently only recognizes String values. This may be updated in the \nfuture.", 
            "title": "JSON "
        }, 
        {
            "location": "/writing/#the-layout-index", 
            "text": "The layout index is the root of every layout model.  {\n     name : SimpleLayout ,\n     root :{...},\n     layouts :{...}\n}  Only 3 properties are currently read in the Layout Index:   name  The layout name. So far this is only used \nto route layout updates when developing with EverLayout Bridge.  root  Layouts are built on UIViews, which become the 'root view'\nof the layout I.E This is where the layout begins.  layouts  EverLayout supports  sub-layouts", 
            "title": "The Layout Index "
        }, 
        {
            "location": "/writing/#the-view-model", 
            "text": "The view model contains layout data for individual UIViews.  {\n     constraints :{...},\n     properties :{...},\n     z-index : 2 ,\n     views :{...}\n}   constraints  See  Writing Constraints  properties  See  View Properties  z-index  See  Z-Index  views  See  Subviews", 
            "title": "The View Model "
        }, 
        {
            "location": "/writing/#view-name", 
            "text": "Every view in the layout (except the root view, see  View Index )\nhas a name and is expressed as a subview of another view in this layout.  {\n    ...\n     views :{\n         subviewName :{\n            ...\n        }\n    }\n}  The key being the view's name, and the value its  view model .  Given the sample, EverLayout would scan this layout's view environment\nfor a property with this name. If it finds one, it will \nmap this view model to that UIView, including adding it as \na subview.  If EverLayout is unable to find the view, it will move on.", 
            "title": "View Name "
        }, 
        {
            "location": "/writing/#creating-new-views", 
            "text": "The default behaviour for EverLayout is to find the view being referenced\nby scanning the properties of its view environment. However in \nsome cases you may wish to create new views from inside the layout \nfile and have them become a part of your layout hierarchy.  This means:   You can create basic views to test layout ideas without having to\nre-compile (when using EverLayout Bridge).  Views with basic functionality (like wrappers for other views)\nno longer need to be described in your code.  More sophisticated layout updates can be made without\nhaving to update your code and re-submit your app.   If your view name is prefixed with  ! , it will be considered a\n'new view' and created during the layout build.  {\n     !newWrapperView :{\n        ...\n    }\n}", 
            "title": "Creating New Views "
        }, 
        {
            "location": "/writing/#creating-new-views-from-uiview-subclasses", 
            "text": "In addition to being able to create new views, you can also\nspecify which UIView subclass you want your new view to be.  {\n     !newImageView:UIImageView : {\n        ...\n    }\n}  Append the name of your new view with  :  followed by \na class name. In the example EverLayout creates a new \nUIImageView.  To create an instance of a custom class, you must also \nspecify your application bundle ID, like so:  !myNewClassInstance:MyApp.MyClassName", 
            "title": "Creating New Views From UIView Subclasses "
        }, 
        {
            "location": "/writing/#writing-constraints", 
            "text": "EverLayout uses AutoLayout constraints to position its elements.\nThe constraints for each view are generated during the layout\nbuild based on key-value rules in the view model.  The format of these constraint rules may not immediately make sense,\nand might take a while to get used to. They're based on ideas\ntaken from  SnapKit .  {\n     constraints :{\n         top right bottom left : @super \n    }\n}  The example above creates 4 NSLayoutConstraints that attach\nthe left, top, right and bottom attributes of this view to \ntheir counterparts in the superview.  {\n     constraints :{\n         bottom left right : @super  8 ,\n         height : @super /2 \n    }\n}  The second example creates constraints which tether the bottom, left and \nright edges to the superview with an 8 unit inset, and then gives this view a height \nof half the superview height.  Each rule is broken into left-hand and right-hand statements (key and value). Both \nstatements contain arguments separated by a space \" \".  For the left-hand statement, any NSLayoutAttribute is valid \nalong with some additional 'compound attributes'.   edges  Translates to  top   left   right   bottom  center  Translates to  centerX   centerY   The right-hand statement can have many arguments, each denoted by\na modifier character.   @  Target a view in the layout / view environment  .  A dot separator can be added to a target name to specify \nan NSLayoutAttribute of that view to target (e.g  @viewName.right )  +  A positive constant  -  A negative constant   A inset constant, which is basically a constant where  +  and  -  are inferred from content  *  A multiplier  /  A divider  !  Constraint identifier (for debugging)  %  A relation (e.g  % =  creates a 'greater than or equal to' relation)  $  A constraint priority   Note: \nEverLayout will try to infer missing constraint properties based\non the information that is supplied.  \"width\": \"@view +12\"  Will create a constraint with the width\nof  view , plus 12 units.  \"width\": \"+12\"  Will create a constraint that has a width of \n12 units.", 
            "title": "Writing Constraints "
        }, 
        {
            "location": "/writing/#view-properties", 
            "text": "Some properties of UIView (and its subclasses) have been made settable\nin the layout files. You can set these under  properties  in the view model.  These are the properties currently available:   UIView    backgroundColor  Color can be the name of the color ( red ) or a hex \nstring ( #333333 ).  cornerRadius  Translates to  layer.cornerRadius  borderWidth  Translates to  layer.borderWidth  borderColor  Translates to  layer.borderColor  alpha  clipToBounds  contentMode    UILabel    text  textColor  lineBreakMode  textAlignment  numberOfLines  fontSize    UIButton    text  Translates to a call to setTitle(...)  textColor  Translates to a call to setTitleColor(...)  backgroundImage  Translates to a call to setBackgroundImage(...)  image  Translates to a call to setImage(...)    UIImageView    image  The value used is passed into UIImage(named: ...)    UIScrollView    contentInset  Value is passed into UIEdgeInsetFromString  contentOffset  Value is passed in CGPointFromString", 
            "title": "View Properties "
        }, 
        {
            "location": "/writing/#z-index", 
            "text": "The order in which EverLayout adds subviews is not always clear. If you\nhave views which overlap each other, the  z-index  can be set \nto tell EverLayout which views should be at the top.  {\n     onBottom : {\n         z-index : 1 \n    },\n     onTop :{\n         z-index : 2 \n    }\n}  Like in CSS, the higher the  z-index  the closer to the surface the view\nwill be.", 
            "title": "Z-Index "
        }, 
        {
            "location": "/writing/#subviews", 
            "text": "Every view in the layout (except the root view) is added as a subview \nof another. Subviews are added like so:  {\n     constraints : {...},\n     properties :{...},\n     views :{\n         firstSubview :{\n            ...\n        },\n         secondSubview : {\n            ...\n        }\n    }\n}  The key is the view's name (see  view names ), and the value\nis the view model (see  view model ).", 
            "title": "Subviews "
        }, 
        {
            "location": "/writing/#sublayouts", 
            "text": "An EverLayout can have 'sub-layouts'.  {\n     name : MainLayoutName ,\n     root :{...},\n     layouts :{\n         exampleSubLayout :{\n             root : {...}\n        },\n         secondSubLayout :{\n             root : {...}\n        }\n    }\n}  A sub-layout has mostly the same structure as a regular layout,\nexcept its name is its key. Technically sub-layouts can also have sub-layouts,\nalthough I can't say I've actually tried this.  For more info on using sub-layouts, see  Reading Layouts .", 
            "title": "Sublayouts "
        }, 
        {
            "location": "/writing/#data-injection", 
            "text": "'Data Injection' is a glorified 'Find and Replace' on your source layout\ndata. You can mark 'variables' in your layout files like so:  {\n     viewName :{\n         properties :{\n             backgroundColor : #{color} \n        }\n    }\n}  Before building your layout:      self.layout?.injectData([\n         color : red \n    ])  EverLayout will replace all instances of  #{color}  in your layout\nwith  red .", 
            "title": "Data Injection "
        }, 
        {
            "location": "/reading/", 
            "text": "Layout Data\n\n\n    let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource: \nViewController\n, ofType: \njson\n, inDirectory: \nLayouts\n)!) as! Data\n\n    self.layout = EverLayout(layoutData: layoutData, layoutIndexParser: LayoutIndexJSONParser())\n\n\n\n\nA layout is initialized with a \nData\n object. Generally layout \ndata would be stored in a file a loaded in from the Bundle, or the layout\ncan be downloaded from a server.\n\n\nThe only requirement here is that your layout is correctly formatted for\nthe parser. By default, EverLayout uses a \nJSON\n parser,\nbut you can make your own parsers for any language by conforming\nto the different \nLayoutParser\n protocols.\n\n\nBuilding Layout\n\n\n    self.layout!.buildLayout(onView: self.view, viewEnvironment: self)\n\n\n\n\nBuilding a layout requires a root view (see \nlayout Index\n)\nand a \nView Environment\n is optional. If left nil,\nthe root view will be used as the view environment.\n\n\n Note \n\n - The instance of EverLayout should be strongly held.\nIf the layout is deallocated, EverLayout Bridge won't be able to update it.\n\n\nView Environment \n\n\nA view environment is an instance of NSObject which contains the properties\nreferenced in the layout file. For instance, in a View Controller, you would\nwant the root view of your layout to be the controller's view, but the controller\nitself is the object containing the other views in your layout.\n\n\n    class ViewController : UIViewController\n    {\n        private var layout : EverLayout(...)\n        public let viewInLayout : UIView = UIView()\n\n        override func viewDidLoad ()\n        {\n            super.viewDidLoad()\n\n            self.layout!.buildLayout(onView: self.view, viewEnvironment: self)\n        }\n    }\n\n\n\n\n{\n    \nname\n:\nViewController\n,\n    \nroot\n:{\n        \nviews\n:{\n            \nviewInLayout\n:{\n                ...\n            }\n        }\n    }\n}\n\n\n\n\nIn the above example, EverLayout will use the ViewController as the View Environment\nand find \nviewInLayout\n as a property. During the build process it will\nadd this view to the root.\n\n\n    let viewEnvironment : NSDictionary = [\n        \nviewInLayout\n: UIView()\n    ]\n\n    self.layout?.buildLayout(onView: self , viewEnvironment: viewEnvironment)\n\n\n\n\nAs EverLayout is looking for an NSObject as a View Environment, you can alternatively\nuse an NSDictionary to directly pass the views into the layout. This is\nhelpful when using sub-layouts.\n\n\n Note \n\n - \nNSDictionary\n can be used because it is a subclass of NSObject. The Swift\n \nDictionary\n is not and will not work.\n\n\n Note \n\n - Properties accessed from the View Environment must be \npublic\n, otherwise\n you will likely face a crash.\n\n\nView Index \n\n\nA View Index is created by the layout when it builds. The View Index keeps\ntrack of all the views created in the layout and allows you to access\nthem after the layout has successfully built.\n\n\n    let wrapperView = self.layout?.viewIndex.view(forKey: \nwrapperView\n)\n\n\n\n\nBeing able to access views from the View Index is helpful when the layout is\ncreating new views (see \nCreating Views\n)\n\n\nEverLayoutDelegate \n\n\nConform to \nEverLayoutDelegate\n and implement \n\nlayout(_ layout:EverLayout , didBuildOnView: UIView)\n\nwhich is called when a layout successfully builds on a view.\n\n\n Note \n \n - Make sure you set the \ndelegate\n before building the layout.\n\n\nSublayouts \n\n\nSee \nWriting Sublayouts\n\n\nSub-layouts can be accessed like so:\n\n\n    let subLayout = self.layout?.getSubLayout(\nsublayout-name\n)\n\n\n\n\nsubLayout\n is just another instance of EverLayout.\n\n\nSub-layouts can be made effective when used with \nData Injection\n\nand \nView Environment\n.", 
            "title": "Reading Layouts"
        }, 
        {
            "location": "/reading/#layout-data", 
            "text": "let layoutData = NSData(contentsOfFile: Bundle.main.path(forResource:  ViewController , ofType:  json , inDirectory:  Layouts )!) as! Data\n\n    self.layout = EverLayout(layoutData: layoutData, layoutIndexParser: LayoutIndexJSONParser())  A layout is initialized with a  Data  object. Generally layout \ndata would be stored in a file a loaded in from the Bundle, or the layout\ncan be downloaded from a server.  The only requirement here is that your layout is correctly formatted for\nthe parser. By default, EverLayout uses a  JSON  parser,\nbut you can make your own parsers for any language by conforming\nto the different  LayoutParser  protocols.", 
            "title": "Layout Data"
        }, 
        {
            "location": "/reading/#building-layout", 
            "text": "self.layout!.buildLayout(onView: self.view, viewEnvironment: self)  Building a layout requires a root view (see  layout Index )\nand a  View Environment  is optional. If left nil,\nthe root view will be used as the view environment.   Note  \n - The instance of EverLayout should be strongly held.\nIf the layout is deallocated, EverLayout Bridge won't be able to update it.", 
            "title": "Building Layout"
        }, 
        {
            "location": "/reading/#view-environment", 
            "text": "A view environment is an instance of NSObject which contains the properties\nreferenced in the layout file. For instance, in a View Controller, you would\nwant the root view of your layout to be the controller's view, but the controller\nitself is the object containing the other views in your layout.      class ViewController : UIViewController\n    {\n        private var layout : EverLayout(...)\n        public let viewInLayout : UIView = UIView()\n\n        override func viewDidLoad ()\n        {\n            super.viewDidLoad()\n\n            self.layout!.buildLayout(onView: self.view, viewEnvironment: self)\n        }\n    }  {\n     name : ViewController ,\n     root :{\n         views :{\n             viewInLayout :{\n                ...\n            }\n        }\n    }\n}  In the above example, EverLayout will use the ViewController as the View Environment\nand find  viewInLayout  as a property. During the build process it will\nadd this view to the root.      let viewEnvironment : NSDictionary = [\n         viewInLayout : UIView()\n    ]\n\n    self.layout?.buildLayout(onView: self , viewEnvironment: viewEnvironment)  As EverLayout is looking for an NSObject as a View Environment, you can alternatively\nuse an NSDictionary to directly pass the views into the layout. This is\nhelpful when using sub-layouts.   Note  \n -  NSDictionary  can be used because it is a subclass of NSObject. The Swift\n  Dictionary  is not and will not work.   Note  \n - Properties accessed from the View Environment must be  public , otherwise\n you will likely face a crash.", 
            "title": "View Environment "
        }, 
        {
            "location": "/reading/#view-index", 
            "text": "A View Index is created by the layout when it builds. The View Index keeps\ntrack of all the views created in the layout and allows you to access\nthem after the layout has successfully built.      let wrapperView = self.layout?.viewIndex.view(forKey:  wrapperView )  Being able to access views from the View Index is helpful when the layout is\ncreating new views (see  Creating Views )", 
            "title": "View Index "
        }, 
        {
            "location": "/reading/#everlayoutdelegate", 
            "text": "Conform to  EverLayoutDelegate  and implement  layout(_ layout:EverLayout , didBuildOnView: UIView) \nwhich is called when a layout successfully builds on a view.   Note   \n - Make sure you set the  delegate  before building the layout.", 
            "title": "EverLayoutDelegate "
        }, 
        {
            "location": "/reading/#sublayouts", 
            "text": "See  Writing Sublayouts  Sub-layouts can be accessed like so:      let subLayout = self.layout?.getSubLayout( sublayout-name )  subLayout  is just another instance of EverLayout.  Sub-layouts can be made effective when used with  Data Injection \nand  View Environment .", 
            "title": "Sublayouts "
        }, 
        {
            "location": "/bridge/", 
            "text": "Overview\n\n\nEverLayout Bridge is a small node powered simple HTTP server which monitors\nlayout files and sends them to the app when they've been updated.\n\n\nYou can get more information on EverLayout Bridge \nhere\n\n\nInstallation\n\n\nnpm install -g ever-layout-bridge\n\n\nConnecting\n\n\nWhen EverLayout Bridge is running, your app needs to make a connection\nto it. It makes most sense to make this connection in your \n\nAppDelegate\n, and also a check for \nDEBUG\n mode might be good.\n\n\n    #if DEBUG\n        EverLayoutBridge.connectToLayoutServer()\n    #endif\n\n\n\n\nOptionally, you can pass an IP Address and a Port number to this \nmethod.", 
            "title": "EverLayout Bridge"
        }, 
        {
            "location": "/bridge/#overview", 
            "text": "EverLayout Bridge is a small node powered simple HTTP server which monitors\nlayout files and sends them to the app when they've been updated.  You can get more information on EverLayout Bridge  here", 
            "title": "Overview"
        }, 
        {
            "location": "/bridge/#installation", 
            "text": "npm install -g ever-layout-bridge", 
            "title": "Installation"
        }, 
        {
            "location": "/bridge/#connecting", 
            "text": "When EverLayout Bridge is running, your app needs to make a connection\nto it. It makes most sense to make this connection in your  AppDelegate , and also a check for  DEBUG  mode might be good.      #if DEBUG\n        EverLayoutBridge.connectToLayoutServer()\n    #endif  Optionally, you can pass an IP Address and a Port number to this \nmethod.", 
            "title": "Connecting"
        }
    ]
}